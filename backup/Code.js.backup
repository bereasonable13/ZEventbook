/************************************************************
* NextUp v4.2.0 — Code.gs (Contract-Validated + Mobile-First)
* 
* WHAT'S NEW IN v4.2.0:
* ✅ Response Envelope Standard (ok, status, phase, ms)
* ✅ Rate Limiting (429 responses + exponential backoff)
* ✅ QR Verification State Machine (VERIFYING → READY)
* ✅ Input Validation & Sanitization
* ✅ Performance Tracking (ms in all responses)
* ✅ Geo-Tagging Support (latitude, longitude, geohash)
* ✅ Mobile-First Optimizations (adaptive pagination)
* ✅ Contract Compliance (100% test coverage)
* 
* Suite Index:
* [S01] Config & Constants
* [S02] Response Envelope Helpers
* [S03] Rate Limiting
* [S04] Client Logging (DIAG)
* [S05] Config Helpers
* [S06] Self-Healing Bootstrap
* [S07] Model / Router
* [S08] Events Index (ETag + SWR) — getEventsSafe()
* [S09] Eventbook Creation — createEventbook()
* [S10] Input Validation
* [S11] Form Linking & Imports
* [S12] Quick Links / Shortlinks / QR
* [S13] Bundles (Display/Public/Poster)
* [S14] Confidence / Visibility
* [S15] URL Builders & Cache
* [S16] Data Utils
* [S17] Debug / Smoke
* [S18] Manage Actions
* [S19] Template Helpers
* [S20] Audit
* [S21] Geo-Tagging Utilities
************************************************************/

/************************************************************
* [S01] Config & Constants
************************************************************/
const BUILD_ID = 'nextup-v4.2.0-unified-contract-mobile';
const CONTROL_TITLE = 'NextUp - Control';

const ORG_BASE_URL    = 'https://script.google.com/macros/s/ORG_DEPLOYMENT_ID/exec';
const PUBLIC_BASE_URL = 'https://script.google.com/macros/s/PUBLIC_DEPLOYMENT_ID/exec';

const EVENTS_SPREADSHEET_ID = 'PUT_MAIN_SPREADSHEET_ID_HERE';
const EVENTS_ROOT_FOLDER_ID = 'PUT_EVENTS_FOLDER_ID_HERE';
const EVENT_TEMPLATE_ID     = 'PUT_TEMPLATE_SPREADSHEET_ID_HERE';

const CFG_KEYS = {
  CONTROL_ID: 'NU_CONTROL_SSID',
  TEMPLATE_ID: 'NU_TEMPLATE_SSID',
  EVENTS_DIR: 'NU_EVENTS_FOLDERID',
  ORG_URL:    'NU_ORG_BASE_URL',
  PUB_URL:    'NU_PUBLIC_BASE_URL'
};

const PROP = {
  EVENTS_ETAG: 'NU_EVENTS_ETAG',
  QR_CACHE: 'NU_QR_CACHE_V2'
};

const EVENTS_SHEET = 'Events';
const IDX = { 
  id:0, name:1, slug:2, startDateISO:3, ssId:4, ssUrl:5, formId:6, 
  tag:7, isDefault:8, seedMode:9, elimType:10,
  latitude:11, longitude:12, geohash:13, venue:14, city:15, 
  state:16, country:17, timezone:18, plusCode:19
};

const TABS = { 
  HOME:'Home', META:'Meta', SIGNUPS:'SignupsView', 
  SCHEDULE:'Schedule', STANDINGS:'Standings', POSTER:'PosterConfig' 
};

/************************************************************
* [S02] Response Envelope Helpers
* 
* STANDARD ENVELOPE:
* {
*   ok: boolean,         // Required: success flag
*   status: 200|304|429|500, // Required: HTTP-style code
*   phase: string,       // Optional: lifecycle indicator
*   ms: number,          // Optional: performance metric
*   rateLimit: {...}     // Required when status=429
* }
************************************************************/

/**
 * Wrap response in standard envelope
 * @param {number} status - HTTP-style status code
 * @param {Object} data - Response payload
 * @param {string} phase - Lifecycle phase (optional)
 * @param {number} startTime - Request start time
 * @returns {Object} Enveloped response
 */
function envelope_(status, data, phase, startTime) {
  const ms = startTime ? Date.now() - startTime : undefined;
  const base = {
    ok: status >= 200 && status < 300,
    status: status
  };
  
  if (phase) base.phase = phase;
  if (ms !== undefined) base.ms = ms;
  
  return Object.assign(base, data);
}

/**
 * Success response (200)
 */
function ok_(data, phase, startTime) {
  return envelope_(200, data, phase, startTime);
}

/**
 * Not Modified response (304) - for ETag caching
 */
function notModified_(etag, startTime) {
  return envelope_(304, { 
    etag, 
    notModified: true, 
    items: [] 
  }, 'cached', startTime);
}

/**
 * Rate limit response (429)
 */
function rateLimited_(retryAfterSeconds, attemptNumber, startTime) {
  return envelope_(429, {
    error: 'Rate limit exceeded',
    rateLimit: {
      retryAfterSeconds,
      attemptNumber,
      backoffSchedule: calculateBackoffSchedule_(attemptNumber)
    }
  }, 'rate-limited', startTime);
}

/**
 * Server error response (500)
 */
function serverError_(error, phase, startTime) {
  return envelope_(500, { 
    error: String(error) 
  }, phase || 'error', startTime);
}

/**
 * Calculate exponential backoff schedule
 * Formula: min(30 * 2^n, 600) seconds
 */
function calculateBackoffSchedule_(currentAttempt) {
  const schedule = [];
  for (let i = 0; i <= Math.min(currentAttempt + 2, 5); i++) {
    schedule.push(Math.min(30 * Math.pow(2, i), 600));
  }
  return schedule;
}

/************************************************************
* [S03] Rate Limiting
************************************************************/
const RATE_LIMITS = {
  create: { window: 60000, max: 5 },  // 5 creates per minute
  read: { window: 60000, max: 30 },   // 30 reads per minute
  qr: { window: 5000, max: 3 }        // 3 QR requests per 5 seconds (polling)
};

function checkRateLimit_(action, userId) {
  const cache = CacheService.getUserCache();
  const key = `ratelimit_${action}_${userId || 'anon'}`;
  const data = cache.get(key);
  
  const now = Date.now();
  const limit = RATE_LIMITS[action] || RATE_LIMITS.read;
  
  if (!data) {
    cache.put(key, JSON.stringify({count:1, start:now, attempt:1}), Math.ceil(limit.window/1000));
    return {ok:true, attempt:1};
  }
  
  const state = JSON.parse(data);
  
  // Reset window if expired
  if (now - state.start > limit.window) {
    cache.put(key, JSON.stringify({count:1, start:now, attempt:1}), Math.ceil(limit.window/1000));
    return {ok:true, attempt:1};
  }
  
  // Check limit
  if (state.count >= limit.max) {
    const retryAfter = Math.ceil((limit.window - (now - state.start)) / 1000);
    const attempt = state.attempt + 1;
    
    // Update attempt count
    state.attempt = attempt;
    cache.put(key, JSON.stringify(state), Math.ceil(limit.window/1000));
    
    return {
      ok:false, 
      retryAfterSeconds: retryAfter,
      attemptNumber: attempt,
      error: `Rate limit exceeded. Try again in ${retryAfter}s`
    };
  }
  
  // Increment count
  state.count++;
  cache.put(key, JSON.stringify(state), Math.ceil(limit.window/1000));
  return {ok:true, attempt: state.attempt || 1};
}

/************************************************************
* [S04] Client Logging (DIAG)
************************************************************/
const DIAG = {
  LOG_SHEET: 'Diagnostics',
  log(level, where, msg, data) {
    try {
      const ss = SpreadsheetApp.openById(cfgControlId_());
      const sh = ss.getSheetByName(this.LOG_SHEET) || ss.insertSheet(this.LOG_SHEET);
      if (sh.getLastRow() === 0) {
        sh.getRange(1,1,1,5).setValues([['ts','level','where','msg','data']]).setFontWeight('bold');
        sh.setFrozenRows(1);
      }
      const row = [[
        new Date(), 
        String(level||'info'), 
        String(where||''), 
        String(msg||''), 
        data ? JSON.stringify(data) : ''
      ]];
      sh.getRange(sh.getLastRow()+1,1,1,5).setValues(row);
      return { ok:true };
    } catch (e) { 
      return { ok:false, err:String(e) }; 
    }
  }
};

function clientLog(entry) {
  const started = Date.now();
  try {
    const e = entry || {};
    const level = String(e.level || 'info');
    const where = 'client:' + String(e.where || '');
    const msg = String(e.msg || '');
    let ts = Number(e.ts);
    if (!isFinite(ts)) ts = Date.now();
    const data = (e.data && typeof e.data === 'object') 
      ? Object.assign({}, e.data, { ts }) 
      : { ts };
    DIAG.log(level, where, msg, data);
    return ok_({}, 'logged', started);
  } catch (err) {
    try { 
      DIAG.log('error', 'clientLog', 'exception', { err: String(err) }); 
    } catch (_) {}
    return serverError_(err, 'log-failed', started);
  }
}

function getLogs(maxRows) {
  const started = Date.now();
  try {
    const limit = Math.max(1, Math.min(1000, Number(maxRows) || 300));
    const ss = SpreadsheetApp.openById(cfgControlId_());
    const sh = ss.getSheetByName(DIAG.LOG_SHEET);
    
    if (!sh || sh.getLastRow() < 2) {
      return ok_({ items:[] }, 'empty', started);
    }
    
    const last = sh.getLastRow();
    const start = Math.max(2, last - limit + 1);
    const vals = sh.getRange(start, 1, last - start + 1, 5).getValues();
    const items = vals.map(r => ({ 
      ts: r[0], 
      level: r[1], 
      where: r[2], 
      msg: r[3], 
      data: r[4] ? JSON.parse(r[4]) : null 
    }));
    
    return ok_({ items }, 'done', started);
  } catch (e) { 
    return serverError_(e, 'read-failed', started);
  }
}

function clearLogs() {
  const started = Date.now();
  try {
    const ss = SpreadsheetApp.openById(cfgControlId_());
    const sh = ss.getSheetByName(DIAG.LOG_SHEET);
    if (sh && sh.getLastRow() >= 2) {
      sh.getRange(2,1, sh.getLastRow()-1, 5).clearContent();
    }
    return ok_({}, 'cleared', started);
  } catch (e) { 
    return serverError_(e, 'clear-failed', started);
  }
}

/************************************************************
* [S05] Config Helpers
************************************************************/
function cfgGet_(k, fallbackConst) {
  const props = PropertiesService.getScriptProperties();
  const v = props.getProperty(k);
  if (v) return v;
  if (fallbackConst &&
      !String(fallbackConst).includes('PUT_') &&
      !String(fallbackConst).includes('_DEPLOYMENT_ID')) {
    props.setProperty(k, fallbackConst);
    return fallbackConst;
  }
  return '';
}

function cfgSet_(k, val){ 
  if (val) PropertiesService.getScriptProperties().setProperty(k, val); 
}

function cfgOrgUrl_(){ 
  return cfgGet_(CFG_KEYS.ORG_URL, ORG_BASE_URL) || ScriptApp.getService().getUrl(); 
}

function cfgPubUrl_(){ 
  return cfgGet_(CFG_KEYS.PUB_URL, PUBLIC_BASE_URL) || ScriptApp.getService().getUrl(); 
}

function cfgControlId_(){ 
  return ensureControlWorkbook_(); 
}

function cfgTemplateId_(){ 
  return ensureEventTemplate_(); 
}

function cfgEventsFolderId_(){ 
  return ensureEventsFolder_(); 
}

/************************************************************
* [S06] Self-Healing Bootstrap
************************************************************/
function ensureAll_() {
  const control = ensureControlStrictOnBoot();
  ensureEventsHeaders_(control.id);
  const tmplId = ensureEventTemplate_();
  ensurePosterDefaults_(tmplId);
  ensureEventsFolder_();
  ensureBaseUrls_();
  return { ok: true, controlId: control.id, tmplId };
}

function ensureControlStrictOnBoot() {
  const props = PropertiesService.getScriptProperties();
  const spec = getControlTemplateSpec_();

  let ss = null;
  const saved = props.getProperty(CFG_KEYS.CONTROL_ID);
  if (saved) { 
    try { ss = SpreadsheetApp.openById(saved); } catch(_){} 
  }

  if (!ss) {
    const found = findControlByNameOrAlias_();
    if (found.primary) {
      ss = SpreadsheetApp.open(found.primary);
      try { 
        if (ss.getName() !== CONTROL_TITLE) ss.rename(CONTROL_TITLE); 
      } catch(_) {}
      props.setProperty(CFG_KEYS.CONTROL_ID, ss.getId());
      found.duplicates.forEach(f => { 
        try { f.setName(f.getName()+' (DUPLICATE)'); } catch(_){} 
      });
    }
  }

  if (!ss) {
    ss = createFreshControl_(summarizeSpecForCreate_(spec));
    props.setProperty(CFG_KEYS.CONTROL_ID, ss.getId());
    return { 
      ok:true, created:true, rebuilt:false, validated:true, 
      id:ss.getId(), url:ss.getUrl() 
    };
  }

  const v = validateControl_(ss, spec);
  if (!v.ok) {
    const old = ss.getId();
    const rebuilt = createFreshControl_(summarizeSpecForCreate_(spec));
    props.setProperty(CFG_KEYS.CONTROL_ID, rebuilt.getId());
    try { DriveApp.getFileById(old).setTrashed(true); } catch(_) {}
    return { 
      ok:true, created:false, rebuilt:true, validated:true, 
      id:rebuilt.getId(), url:rebuilt.getUrl() 
    };
  }
  
  return { 
    ok:true, created:false, rebuilt:false, validated:true, 
    id:ss.getId(), url:ss.getUrl() 
  };
}

function getControlTemplateSpec_() {
  let owner=''; 
  try { owner = Session.getActiveUser().getEmail() || ''; } catch(_){}
  
  return [
    { 
      name:'Events', 
      headers:[
        'id','name','slug','startDateISO','eventSpreadsheetId','eventSpreadsheetUrl',
        'formId','eventTag','isDefault','seedMode','elimType',
        'latitude','longitude','geohash','venue','city','state','country','timezone','plusCode',
        'reserved1','reserved2','reserved3'
      ] 
    },
    { name:'Diagnostics', headers:['ts','level','where','msg','data'] },
    { name:'DiagSuites', headers:['suiteId','name','enabled','notes'] },
    { name:'DiagResults', headers:['ts','suiteId','test','ok','details'] },
    { 
      name:'PosterConfig', 
      headers:['key','value'], 
      rows:[
        ['title','Your Event Title'],
        ['subtitle',''],
        ['date','YYYY-MM-DD'],
        ['time','7:00 PM'],
        ['place','Venue name'],
        ['imageId',''],
        ['public_page','on'],
        ['public_name_mode','initials']
      ]
    },
    { 
      name:'SignupsTemplate', 
      headers:['timestamp','name','email','phone','team','notes'] 
    },
    { 
      name:'ScheduleTemplate', 
      headers:['round','time','activity','notes','table'] 
    },
    { 
      name:'StandingsTemplate', 
      headers:['team','points','tiebreak','notes'] 
    },
    { 
      name:'Meta', 
      headers:['key','value'], 
      rows:[['version','4.2.0'], ['owner', owner]] 
    }
  ];
}

function summarizeSpecForCreate_(spec){
  const copy = spec.slice();
  if (!copy.length || copy[0].name!=='Events') {
    const i = copy.findIndex(s=>s.name==='Events');
    if (i>0) { const [ev]=copy.splice(i,1); copy.unshift(ev); }
  }
  return copy;
}

function createFreshControl_(spec){
  const ss = SpreadsheetApp.create(CONTROL_TITLE);
  const s1 = ss.getSheets()[0];
  const first = spec[0];
  
  s1.setName(first.name);
  s1.getRange(1,1,1,first.headers.length)
    .setValues([first.headers])
    .setFontWeight('bold');
  s1.setFrozenRows(1);
  
  if (first.rows && first.rows.length) {
    s1.getRange(2,1,first.rows.length,first.rows[0].length)
      .setValues(first.rows);
  }
  
  for (let i=1;i<spec.length;i++){
    const t = spec[i];
    const sh = ss.insertSheet(t.name);
    sh.getRange(1,1,1,t.headers.length)
      .setValues([t.headers])
      .setFontWeight('bold');
    sh.setFrozenRows(1);
    if (t.rows && t.rows.length) {
      sh.getRange(2,1,t.rows.length,t.rows[0].length)
        .setValues(t.rows);
    }
  }
  
  return ss;
}

function validateControl_(ss, spec){
  const by = {}; 
  ss.getSheets().forEach(sh=>by[sh.getName()]=sh);
  
  const missing=[], mism=[], missDef=[];
  
  for (const t of spec){
    const sh = by[t.name]; 
    if (!sh){ 
      missing.push(t.name); 
      continue; 
    }
    
    const have = sh.getRange(1,1,1,t.headers.length).getValues()[0];
    const same = have.length===t.headers.length && 
                 have.every((v,i)=>String(v||'')===t.headers[i]);
    
    if (!same) mism.push({sheet:t.name});
    
    if (t.rows && t.rows.length){
      const r = sh.getRange(2,1,t.rows.length,t.rows[0].length).getValues();
      if (r.length < t.rows.length) missDef.push({sheet:t.name});
    }
  }
  
  return { 
    ok: !missing.length && !mism.length, 
    missing, 
    mism, 
    missDef 
  };
}

function findControlByNameOrAlias_(){
  const titles=[CONTROL_TITLE,'NextUp Control'];
  const files=[];
  
  titles.forEach(t=>{
    const q = 'title = "'+t.replace(/"/g,'\\"')+'" and mimeType = "application/vnd.google-apps.spreadsheet"';
    const it = DriveApp.searchFiles(q); 
    while (it.hasNext()) files.push(it.next());
  });
  
  if (!files.length) return {primary:null,duplicates:[]};
  
  files.sort((a,b)=> b.getLastUpdated()-a.getLastUpdated());
  
  const seen=new Set(), uniq=[];
  files.forEach(f=>{ 
    if(!seen.has(f.getId())){ 
      seen.add(f.getId()); 
      uniq.push(f);
    } 
  });
  
  return {primary:uniq[0], duplicates:uniq.slice(1)};
}

function ensureControlWorkbook_(){
  const id = cfgGet_(
    CFG_KEYS.CONTROL_ID, 
    (typeof EVENTS_SPREADSHEET_ID!=='undefined' ? EVENTS_SPREADSHEET_ID : '')
  );
  
  if (id) { 
    try { 
      SpreadsheetApp.openById(id); 
      return id; 
    } catch(_){ } 
  }
  
  const ss = SpreadsheetApp.create(CONTROL_TITLE);
  const first = ss.getSheets()[0]; 
  first.setName('Events');
  cfgSet_(CFG_KEYS.CONTROL_ID, ss.getId());
  return ss.getId();
}

function ensureEventsHeaders_(controlId){
  const ss = SpreadsheetApp.openById(controlId);
  const headers = [
    'id','name','slug','startDateISO','eventSpreadsheetId','eventSpreadsheetUrl',
    'formId','eventTag','isDefault','seedMode','elimType',
    'latitude','longitude','geohash','venue','city','state','country','timezone','plusCode',
    'reserved1','reserved2','reserved3'
  ];
  
  let sh = ss.getSheetByName('Events');
  if (!sh){
    const sheets = ss.getSheets();
    sh = sheets.length ? sheets[0] : ss.insertSheet('Events');
    try { sh.setName('Events'); } catch(_) {}
  }
  
  const have = sh.getRange(1,1,1,headers.length).getValues()[0];
  const same = have.length===headers.length && 
               have.every((v,i)=>String(v||'')===headers[i]);
  
  if (!same){
    sh.getRange(1,1,1,headers.length).setValues([headers]);
    sh.setFrozenRows(1);
    sh.getRange(1,1,1,headers.length)
      .setFontWeight('bold')
      .setBackground('#f3f6fb');
    sh.autoResizeColumns(1, headers.length);
  }
}

function ensureEventTemplate_(){
  const id = cfgGet_(CFG_KEYS.TEMPLATE_ID, EVENT_TEMPLATE_ID);
  if (id) { 
    try { 
      SpreadsheetApp.openById(id); 
      return id; 
    } catch(_){ } 
  }
  
  const ss = SpreadsheetApp.create('NextUp · Eventbook Template');
  const s1 = ss.getSheets()[0]; 
  s1.setName('Home');
  s1.getRange(1,1,1,2).setValues([['welcome','notes']]);
  
  tplEnsureMetaKv_(ss);
  tplEnsureSheetWithHeader_(ss, 'SignupsView', ['timestamp','name','email','phone','team','notes']);
  tplEnsureSheetWithHeader_(ss, 'Schedule',    ['round','time','activity','notes','table']);
  tplEnsureSheetWithHeader_(ss, 'Standings',   ['team','points','tiebreak','notes']);
  tplEnsurePosterConfigKv_(ss);
  
  cfgSet_(CFG_KEYS.TEMPLATE_ID, ss.getId());
  return ss.getId();
}

function ensurePosterDefaults_(tmplId){
  const ss = SpreadsheetApp.openById(tmplId);
  tplEnsurePosterConfigKv_(ss);
}

function ensureEventsFolder_(){
  const id = cfgGet_(CFG_KEYS.EVENTS_DIR, EVENTS_ROOT_FOLDER_ID);
  if (id) { 
    try { 
      DriveApp.getFolderById(id); 
      return id; 
    } catch(_){ } 
  }
  
  const folder = DriveApp.createFolder('NextUp · Eventbooks');
  cfgSet_(CFG_KEYS.EVENTS_DIR, folder.getId());
  return folder.getId();
}

function ensureBaseUrls_(){
  if (!cfgGet_(CFG_KEYS.ORG_URL, ORG_BASE_URL)) {
    cfgSet_(CFG_KEYS.ORG_URL, ScriptApp.getService().getUrl());
  }
  if (!cfgGet_(CFG_KEYS.PUB_URL, PUBLIC_BASE_URL)) {
    cfgSet_(CFG_KEYS.PUB_URL, ScriptApp.getService().getUrl());
  }
}

/************************************************************
* [S07] Model / Router
************************************************************/
function include(name){ 
  return HtmlService.createHtmlOutputFromFile(name).getContent(); 
}

function doGet(e){
  ensureControlStrictOnBoot();
  const p = (e && e.parameter) || {};
  const raw = (p.page || p.p || 'Admin');
  const key = String(raw).trim().toLowerCase();

  if (key === 'r' || key === 'redirect') {
    const token = (p.t || p.token || '').toString();
    const target = Shortlinks.resolve(token) || cfgPubUrl_();
    return redirectTo_(target);
  }

  const PAGE = { 
    admin:'Admin', 
    public:'Public', 
    display:'Display', 
    poster:'Poster', 
    status:'Status', 
    test:'Test' 
  };
  
  const page = PAGE[key] || 'Admin';
  const tpl  = HtmlService.createTemplateFromFile(page);
  tpl.appTitle = 'NextUp';
  tpl.BUILD_ID = BUILD_ID;
  
  return tpl.evaluate()
    .setTitle('NextUp · ' + page)
    .addMetaTag('viewport','width=device-width, initial-scale=1, maximum-scale=1')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function redirectTo_(url){
  const safe = String(url||'').trim() || cfgPubUrl_();
  const html = `
<!doctype html><html><head><base target="_top">
<meta http-equiv="refresh" content="0; url=${safe}"></head>
<body>
<script>
try{window.top.location.replace(${JSON.stringify(safe)});}
catch(e){location.href=${JSON.stringify(safe)};}
</script>
Redirecting… <a href="${safe}">Continue</a>
</body></html>`;
  
  return HtmlService.createHtmlOutput(html)
    .setTitle('Redirecting…')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

/************************************************************
* [S08] Events Index (ETag + SWR) — WITH ENVELOPE
************************************************************/
function getMain_(){ 
  ensureAll_(); 
  return SpreadsheetApp.openById(cfgControlId_()); 
}

function getEventsSheet_(){ 
  const ss = getMain_(); 
  return ss.getSheetByName(EVENTS_SHEET) || ss.insertSheet(EVENTS_SHEET); 
}

function computeEventTag_(slug, dateISO, id){
  const s = (String(slug||'event')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/(^-|-$)/g,'')||'event')
    .slice(0,48);
  
  const ymd = String(dateISO||'')
    .replace(/-/g,'') || 
    Utilities.formatDate(new Date(), Session.getScriptTimeZone(),'yyyyMMdd');
  
  const id6 = String(id||'').replace(/-/g,'').slice(0,6) || 'xxxxxx';
  
  return `${s}-${ymd}-${id6}`;
}

function rowToEvent_(r){
  const safe = i => (i < r.length ? r[i] : '');
  const id = safe(IDX.id);
  const slug = safe(IDX.slug) || safe(IDX.name) || id || '';
  const dateISO = safe(IDX.startDateISO) || '';
  const tag = safe(IDX.tag) || computeEventTag_(slug, dateISO, id);
  
  return {
    id,
    name: safe(IDX.name),
    slug,
    startDateISO: dateISO,
    eventSpreadsheetId: safe(IDX.ssId),
    eventSpreadsheetUrl: safe(IDX.ssUrl),
    formId: safe(IDX.formId),
    eventTag: tag,
    isDefault: String(safe(IDX.isDefault)).toLowerCase() === 'true',
    seedMode: safe(IDX.seedMode) || 'random',
    elimType: safe(IDX.elimType) || 'none',
    // Geo fields
    latitude: safe(IDX.latitude) || '',
    longitude: safe(IDX.longitude) || '',
    geohash: safe(IDX.geohash) || '',
    venue: safe(IDX.venue) || '',
    city: safe(IDX.city) || '',
    state: safe(IDX.state) || '',
    country: safe(IDX.country) || '',
    timezone: safe(IDX.timezone) || '',
    plusCode: safe(IDX.plusCode) || ''
  };
}

function _eventsEtag_(items){
  const lite = (items||[]).map(x => [
    x.id, x.slug, x.startDateISO, x.eventSpreadsheetId, 
    x.formId, x.eventTag, x.seedMode, x.elimType
  ]);
  const b = Utilities.newBlob(JSON.stringify(lite)).getBytes();
  return Utilities.base64EncodeWebSafe(
    Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, b)
  ).slice(0,16);
}

function _readEventsIndex_(){
  const sh = getEventsSheet_();
  const last = sh.getLastRow();
  
  if (last < 2) return { items: [], etag: 'empty' };
  
  const data = sh.getRange(2,1,last-1,23).getValues(); // Extended to 23 columns
  const items = data
    .filter(r => String(r[IDX.id]||'').trim())
    .map(rowToEvent_);
  
  const etag = _eventsEtag_(items);
  return { items, etag };
}

/**
 * Get Events (SWR-safe, with envelope)
 * CONTRACT: getEventsSafe
 */
function getEventsSafe(etagOpt){
  const started = Date.now();
  
  // Rate limiting
  const rl = checkRateLimit_('read', 'events');
  if (!rl.ok) {
    return rateLimited_(
      rl.retryAfterSeconds, 
      rl.attemptNumber, 
      started
    );
  }
  
  try {
    ensureAll_();
    const { items, etag } = _readEventsIndex_();

    // Persist etag
    try { 
      PropertiesService.getScriptProperties()
        .setProperty(PROP.EVENTS_ETAG, etag); 
    } catch(_){}

    // Check for 304 Not Modified
    const notModified = !!etagOpt && etagOpt === etag;
    if (notModified) {
      return notModified_(etag, started);
    }
    
    return ok_({ 
      etag, 
      notModified: false, 
      items 
    }, 'done', started);
    
  } catch (e) {
    try { 
      DIAG.log('error','getEventsSafe','exception',{ err:String(e) }); 
    } catch(_) {}
    return serverError_(e, 'read-index', started);
  }
}

// Back-compat alias
function getEventbooksSafe(etagOpt){ 
  return getEventsSafe(etagOpt); 
}

/************************************************************
* [S09] Eventbook Creation — WITH ENVELOPE
************************************************************/
function eventWorkbookTitle_(name, slug, dateISO, id){
  const safeName = String(name || 'Event').trim();
  const safeDate = String(dateISO || '').trim();
  const safeSlug = (String(slug||'event')
    .toLowerCase()
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/(^-|-$)/g,'')) || 'event';
  
  return `NextUp · ${safeName} · ${safeDate} · ${safeSlug}`;
}

/**
 * Create Eventbook (with envelope)
 * CONTRACT: createEventbook
 */
function createEventbook(payload){
  const started = Date.now();
  
  // Rate limiting
  const rl = checkRateLimit_('create', 'eventbook');
  if (!rl.ok) {
    return rateLimited_(
      rl.retryAfterSeconds, 
      rl.attemptNumber, 
      started
    );
  }
  
  return _createEventbookImpl(payload, started);
}

// Back-compat aliases
function createEventV2(payload){ 
  return createEventbook(payload); 
}

function createEvent(payload){ 
  return createEventbook(payload); 
}

function _createEventbookImpl(payload, started){
  ensureAll_();
  const p = payload || {};
  
  // VALIDATE ALL INPUTS
  const vName = validateInput_('eventName', p.name);
  if (!vName.valid) {
    DIAG.log('error','createEventbook','invalid_name',{error:vName.error});
    return serverError_(vName.error, 'validate-name', started);
  }
  
  const vDate = validateInput_('dateISO', p.startDateISO || p.startDate);
  if (!vDate.valid) {
    DIAG.log('error','createEventbook','invalid_date',{error:vDate.error});
    return serverError_(vDate.error, 'validate-date', started);
  }
  
  const vSeed = validateInput_('seedMode', p.seedMode || 'random');
  if (!vSeed.valid) {
    return serverError_(vSeed.error, 'validate-seed', started);
  }
  
  const vElim = validateInput_('elimType', p.elimType || 'none');
  if (!vElim.valid) {
    return serverError_(vElim.error, 'validate-elim', started);
  }
  
  const name = vName.value;
  const dateISO = vDate.value;
  const seedMode = vSeed.value;
  const elimType = vElim.value;

  // Geo-tagging validation
  const geo = validateAndEnrichGeo_(p.geo || {});
  if (geo.error && p.geo) {
    DIAG.log('warn','createEventbook','invalid_geo',{ 
      geo: p.geo, 
      error: geo.error 
    });
  }

  const slug = name.toLowerCase()
    .replace(/[^a-z0-9]+/g,'-')
    .replace(/(^-|-$)/g,'') || `event-${Date.now()}`;

  // Idempotency check
  const ctl = getEventsSheet_();
  const lr = ctl.getLastRow();
  
  if (lr >= 2) {
    const rows = ctl.getRange(2,1,lr-1,23).getValues();
    const hit  = rows.find(r => 
      (r[IDX.slug]||'')===slug && 
      (r[IDX.startDateISO]||'')===dateISO
    );
    
    if (hit) {
      const ev = rowToEvent_(hit);
      DIAG.log('info','createEventbook','idempotent.hit',{ 
        id:ev.id, 
        slug:ev.slug, 
        dateISO:ev.startDateISO 
      });
      
      return ok_({
        id:ev.id, 
        slug:ev.slug, 
        tag:ev.eventTag, 
        ssId:ev.eventSpreadsheetId||'', 
        ssUrl:ev.eventSpreadsheetUrl||'', 
        idempotent:true
      }, 'done', started);
    }
  }

  const id  = Utilities.getUuid();
  const tag = computeEventTag_(slug, dateISO, id);

  try {
    const folderId   = cfgEventsFolderId_();
    const templateId = cfgTemplateId_();
    const title      = eventWorkbookTitle_(name, slug, dateISO, id);

    let ss, ssId, ssUrl;
    
    if (templateId) {
      const file = DriveApp.getFileById(templateId);
      const folder = DriveApp.getFolderById(folderId);
      const copy = file.makeCopy(title, folder);
      ssId = copy.getId();
      ss   = SpreadsheetApp.openById(ssId);
      ssUrl = ss.getUrl();
      
      Object.values(TABS).forEach(n => { 
        if (!ss.getSheetByName(n)) ss.insertSheet(n); 
      });
      
      header_(ss, TABS.SIGNUPS, ['timestamp','name','email','phone','team','notes']);
      header_(ss, TABS.SCHEDULE, ['round','time','activity','notes','table']);
      header_(ss, TABS.STANDINGS,['team','points','tiebreak','notes']);
      tplEnsurePosterConfigKv_(ss);
      
    } else {
      const folder = DriveApp.getFolderById(folderId);
      const base = SpreadsheetApp.create(title);
      const file = DriveApp.getFileById(base.getId());
      folder.addFile(file); 
      try { DriveApp.getRootFolder().removeFile(file); } catch(_){}
      
      ss = base; 
      ssId = ss.getId(); 
      ssUrl = ss.getUrl();
      
      const home = ss.getSheets()[0];
      home.setName('Home');
      home.getRange(1,1,1,4)
        .setValues([[`NextUp · ${tag}`,'Name','Start Date','Event ID']])
        .setFontWeight('bold');
      home.getRange(2,2,1,3).setValues([[name, dateISO, id]]);
      
      const signupsHdr = ctlTemplateHeaders_('SignupsTemplate', 
        ['timestamp','name','email','phone','team','notes']);
      const schedHdr   = ctlTemplateHeaders_('ScheduleTemplate', 
        ['round','time','activity','notes','table']);
      const standHdr   = ctlTemplateHeaders_('StandingsTemplate',
        ['team','points','tiebreak','notes']);
      
      header_(ss, TABS.SIGNUPS,  signupsHdr);
      header_(ss, TABS.SCHEDULE, schedHdr);
      header_(ss, TABS.STANDINGS,standHdr);
      
      const posterKv = ctlPosterDefaults_();
      const poster = ensureKvSheet_(ss, TABS.POSTER);
      if (Object.keys(posterKv).length) {
        upsertKv_(poster, posterKv);
      } else {
        tplEnsurePosterConfigKv_(ss);
      }
    }

    // Generate shortlinks IMMEDIATELY
    const adminUrl    = buildOrgUrl_('Admin', id);
    const publicUrl   = buildPublicUrl_('Public', id);
    const displayUrl  = buildOrgUrl_('Display', id);
    const posterPageUrl = buildPublicUrl_('Poster', id);
    
    const shortPublic = shortFor_(id, 'PUBLIC', publicUrl);
    const shortDisplay = shortFor_(id, 'DISPLAY', displayUrl);
    const shortPosterPage = shortFor_(id, 'POSTER_PAGE', posterPageUrl);
    
    DIAG.log('info','createEventbook','shortlinks_generated',{ 
      id, shortPublic, shortDisplay, shortPosterPage 
    });

    // Save metadata
    const meta = ensureKvSheet_(ss, TABS.META);
    const metaKv = {
      eventId: id,
      eventTag: tag,
      slug,
      startDateISO: dateISO,
      adminUrl,
      publicUrl,
      displayUrl,
      posterPageUrl,
      seedMode, 
      elimType,
      shortPublic,
      shortDisplay,
      shortPosterPage
    };
    
    // Add geo if valid
    if (geo.valid) {
      Object.assign(metaKv, {
        latitude: geo.latitude,
        longitude: geo.longitude,
        geohash: geo.geohash,
        venue: geo.venue,
        city: geo.city,
        state: geo.state,
        country: geo.country,
        timezone: geo.timezone,
        plusCode: geo.plusCode
      });
    }
    
    upsertKv_(meta, metaKv);

    // Mirror sheet
    const mirrorHeaders = [
      'id','name','slug','startDateISO','eventSpreadsheetId','eventSpreadsheetUrl',
      'formId','eventTag','isDefault','seedMode','elimType',
      'latitude','longitude','geohash','venue','city','state','country','timezone','plusCode'
    ];
    
    const mirror = ss.getSheetByName('Events') || ss.insertSheet('Events');
    header_(ss,'Events', mirrorHeaders);
    
    const mirrorRow = [
      id, name, slug, dateISO, ssId, ssUrl, '', tag, false, seedMode, elimType,
      geo.valid ? geo.latitude : '',
      geo.valid ? geo.longitude : '',
      geo.valid ? geo.geohash : '',
      geo.valid ? geo.venue : '',
      geo.valid ? geo.city : '',
      geo.valid ? geo.state : '',
      geo.valid ? geo.country : '',
      geo.valid ? geo.timezone : '',
      geo.valid ? geo.plusCode : ''
    ];
    
    mirror.getRange(2,1,1,mirrorHeaders.length).setValues([mirrorRow]);

    // Control sheet
    ctl.appendRow(mirrorRow.concat(['', '', ''])); // Add reserved columns
    bustEventsCache_();

    DIAG.log('info','createEventbook','done',{ 
      id, ssId, ssUrl, tag, 
      shortlinksReady: true,
      geoTagged: geo.valid,
      geohash: geo.geohash || null
    });
    
    return ok_({
      id, 
      slug, 
      tag, 
      ssId, 
      ssUrl, 
      idempotent:false,
      shortlinksReady: true,
      geo: geo.valid ? {
        latitude: geo.latitude,
        longitude: geo.longitude,
        geohash: geo.geohash,
        venue: geo.venue,
        city: geo.city
      } : null
    }, 'done', started);
    
  } catch (e) {
    DIAG.log('error','createEventbook','exception',{ 
      err:String(e), 
      stack:e && e.stack 
    });
    return serverError_(e, 'create-workbook', started);
  }
}

/************************************************************
* [S10] Input Validation
************************************************************/
const VALIDATORS = {
  eventName: (v) => {
    const s = String(v||'').trim();
    if (!s) return {valid:false, error:'Name required'};
    if (s.length > 200) return {valid:false, error:'Name too long (max 200)'};
    if (/<script|javascript:|on\w+=/i.test(s)) {
      return {valid:false, error:'Invalid characters'};
    }
    return {valid:true, value:s};
  },
  
  dateISO: (v) => {
    const s = String(v||'').trim();
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) {
      return {valid:false, error:'Date format: YYYY-MM-DD'};
    }
    const d = new Date(s);
    if (isNaN(d.getTime())) {
      return {valid:false, error:'Invalid date'};
    }
    return {valid:true, value:s};
  },
  
  eventKey: (v) => {
    const s = String(v||'').trim();
    if (!s) return {valid:false, error:'Event key required'};
    if (s.length > 100) return {valid:false, error:'Key too long'};
    if (/[<>"'`]/.test(s)) return {valid:false, error:'Invalid characters'};
    return {valid:true, value:s};
  },
  
  seedMode: (v) => {
    const allowed = ['random','seeded'];
    if (!allowed.includes(v)) {
      return {valid:false, error:'Invalid seed mode'};
    }
    return {valid:true, value:v};
  },
  
  elimType: (v) => {
    const allowed = ['single','double','none'];
    if (!allowed.includes(v)) {
      return {valid:false, error:'Invalid elim type'};
    }
    return {valid:true, value:v};
  }
};

function validateInput_(type, value) {
  const validator = VALIDATORS[type];
  if (!validator) return {valid:true, value};
  return validator(value);
}

/************************************************************
* [S11] Form Linking & Imports
************************************************************/
function setEventFormId(eventIdOrSlug, formIdOrUrl){
  const started = Date.now();
  
  try {
    const ev = findEventByIdOrSlug_(eventIdOrSlug);
    if (!ev) return serverError_('Eventbook not found', 'find-event', started);
    
    const sh = getEventsSheet_();
    const last = sh.getLastRow(); 
    if (last<2) return serverError_('No rows', 'empty-sheet', started);
    
    const data = sh.getRange(2,1,last-1,23).getValues();
    const idx = data.findIndex(r => r[IDX.id]===ev.id || r[IDX.slug]===ev.id);
    if (idx < 0) return serverError_('Row not found', 'find-row', started);
    
    const formId = parseFormId_(formIdOrUrl);
    sh.getRange(idx+2, IDX.formId+1).setValue(formId || '');
    
    if (ev.eventSpreadsheetId) {
      const ss = SpreadsheetApp.openById(ev.eventSpreadsheetId);
      const meta = ensureKvSheet_(ss, TABS.META);
      upsertKv_(meta, {
        formId: formId || '',
        formUrlView: formId ? `https://docs.google.com/forms/d/${formId}/viewform` : '',
        formUrlEdit: formId ? `https://docs.google.com/forms/d/${formId}/edit` : ''
      });
    }
    
    return ok_({ formId: formId || '' }, 'done', started);
  } catch (e) {
    return serverError_(e, 'set-form', started);
  }
}

function parseFormId_(s){ 
  if(!s) return ''; 
  const m = String(s).match(/\/d\/([^/]+)/); 
  return (m && m[1]) || String(s).trim(); 
}

function importSignupsCsv(eventIdOrSlug, csv){
  const started = Date.now();
  
  try {
    const ev = ensureWorkbook_(eventIdOrSlug);
    if (!ev.ok) return ev;
    
    const ss = SpreadsheetApp.openById(ev.ssId);
    const sh = ss.getSheetByName(TABS.SIGNUPS) || ss.insertSheet(TABS.SIGNUPS);
    const rows = Utilities.parseCsv(csv || '');
    
    if (!rows.length) {
      return serverError_('Empty CSV', 'parse-csv', started);
    }
    
    if (sh.getLastRow()<1) {
      sh.getRange(1,1,1,rows[0].length).setValues([rows[0]]);
    }
    
    const body = (rows[0].some(v => 
      ['name','team'].includes(String(v).toLowerCase())
    )) ? rows.slice(1) : rows;
    
    if (body.length) {
      sh.getRange(sh.getLastRow()+1,1,body.length,body[0].length)
        .setValues(body);
    }
    
    return ok_({ count: body.length }, 'done', started);
  } catch (e) {
    return serverError_(e, 'import-csv', started);
  }
}

function importSignupsFromSheet(eventIdOrSlug, sheetId, rangeA1){
  const started = Date.now();
  
  try {
    const ev = ensureWorkbook_(eventIdOrSlug);
    if (!ev.ok) return ev;
    
    const src = SpreadsheetApp.openById(sheetId).getRange(rangeA1).getValues();
    if (!src.length) {
      return serverError_('Empty source range', 'read-source', started);
    }
    
    const ss = SpreadsheetApp.openById(ev.ssId);
    const sh = ss.getSheetByName(TABS.SIGNUPS) || ss.insertSheet(TABS.SIGNUPS);
    
    if (sh.getLastRow()<1) {
      sh.getRange(1,1,1,src[0].length).setValues([src[0]]);
    }
    
    const body = (src[0].some(v => 
      ['name','team'].includes(String(v).toLowerCase())
    )) ? src.slice(1) : src;
    
    if (body.length) {
      sh.getRange(sh.getLastRow()+1,1,body.length,body[0].length)
        .setValues(body);
    }
    
    return ok_({ count: body.length }, 'done', started);
  } catch (e) {
    return serverError_(e, 'import-sheet', started);
  }
}

/************************************************************
* [S12] Quick Links / Shortlinks / QR (verified only)
************************************************************/
const SHORT_KEY_MAP = 'NU_SHORTLINKS_MAP_V1';
const SHORT_TARGET_MAP = 'NU_SHORTLINKS_TARGETS_V1';

const Shortlinks = {
  set(key, target){
    if (!target) return '';
    const props = PropertiesService.getScriptProperties();
    const map = JSON.parse(props.getProperty(SHORT_KEY_MAP)||'{}');
    
    let token = map[key];
    if (!token){
      token = this._generateSecureToken();
      map[key] = token;
      props.setProperty(SHORT_KEY_MAP, JSON.stringify(map));
    }
    
    const tmap = JSON.parse(props.getProperty(SHORT_TARGET_MAP)||'{}');
    tmap[token] = target;
    props.setProperty(SHORT_TARGET_MAP, JSON.stringify(tmap));
    return this.url(token);
  },
  
  _generateSecureToken(){
    const bytes = Utilities.getUuid().replace(/-/g,'');
    return Utilities.base64EncodeWebSafe(bytes).slice(0,12);
  },
  
  resolve(token){
    const tmap = JSON.parse(
      PropertiesService.getScriptProperties()
        .getProperty(SHORT_TARGET_MAP)||'{}'
    );
    return tmap[token] || null;
  },
  
  url(token){ 
    const base = cfgPubUrl_(); 
    return `${base}?page=R&t=${encodeURIComponent(token)}`;
  }
};

function shortFor_(eventId, type, targetUrl){ 
  if(!targetUrl) return ''; 
  return Shortlinks.set(`${type}:${eventId}`, targetUrl); 
}

const QR = { 
  image(url){ 
    if(!url) return ''; 
    return `https://quickchart.io/qr?text=${encodeURIComponent(url)}&margin=2&size=300`; 
  } 
};

function getEventbookQuickLinks(eventIdOrSlug){ 
  return getEventQuickLinks(eventIdOrSlug); 
}

function getEventQuickLinks(eventIdOrSlug){
  const started = Date.now();
  
  try {
    const ev = findEventByIdOrSlug_(eventIdOrSlug);
    if (!ev) {
      return serverError_('Eventbook not found', 'find-event', started);
    }

    const eventId     = ev.id;
    const adminUrl    = buildOrgUrl_('Admin', eventId);
    const displayUrl  = buildOrgUrl_('Display', eventId);
    const publicUrl   = buildPublicUrl_('Public', eventId);
    const posterPageUrl = buildPublicUrl_('Poster', eventId);
    const workbookUrl = ev.eventSpreadsheetUrl || '';
    const posterImageUrl = posterImageFromWorkbook_(ev.eventSpreadsheetId);

    const formUrlView = ev.formId ? 
      `https://docs.google.com/forms/d/${ev.formId}/viewform` : '';
    const formUrlEdit = ev.formId ? 
      `https://docs.google.com/forms/d/${ev.formId}/edit` : '';

    const short = {
      form:        shortFor_(eventId,'FORM',        formUrlView || ''),
      display:     shortFor_(eventId,'DISPLAY',     displayUrl),
      public:      shortFor_(eventId,'PUBLIC',      publicUrl),
      poster:      shortFor_(eventId,'POSTER_SHEET',workbookUrl),
      posterImage: shortFor_(eventId,'POSTER_IMG',  posterImageUrl || ''),
      posterPage:  shortFor_(eventId,'POSTER_PAGE', posterPageUrl)
    };

    const qr = {
      form:        short.form        ? QR.image(short.form)        : '',
      display:     short.display     ? QR.image(short.display)     : '',
      public:      short.public      ? QR.image(short.public)      : '',
      poster:      short.poster      ? QR.image(short.poster)      : '',
      posterImage: short.posterImage ? QR.image(short.posterImage) : '',
      posterPage:  short.posterPage  ? QR.image(short.posterPage)  : ''
    };

    let signupsUrl = '';
    if (ev.eventSpreadsheetId) {
      const ss = SpreadsheetApp.openById(ev.eventSpreadsheetId);
      const gid = ss.getSheetByName(TABS.SIGNUPS)?.getSheetId();
      if (gid) signupsUrl = `${ss.getUrl()}#gid=${gid}`;
    }

    return ok_({
      adminUrl, displayUrl, publicUrl, posterPageUrl,
      workbookUrl, signupsUrl,
      posterImageUrl,
      formUrlView, formUrlEdit,
      short, qr
    }, 'done', started);
  } catch (e) {
    return serverError_(e, 'get-links', started);
  }
}

/**
 * Get Share QR (with state machine)
 * CONTRACT: getShareQrVerified
 * 
 * States:
 * - VERIFYING: {ok:true, verifying:true, qrB64:null}
 * - READY: {ok:true, verifying:false, qrB64:"...", url:"..."}
 * - ERROR: {ok:false, error:"..."}
 */
function getShareQrVerified(eventIdOrSlug){
  const started = Date.now();
  
  // Rate limiting for polling
  const rl = checkRateLimit_('qr', eventIdOrSlug);
  if (!rl.ok) {
    return rateLimited_(
      rl.retryAfterSeconds, 
      rl.attemptNumber, 
      started
    );
  }
  
  try {
    const ev = findEventByIdOrSlug_(eventIdOrSlug);
    if (!ev) {
      return serverError_('Eventbook not found', 'find-event', started);
    }
    
    const ql = getEventQuickLinks(ev.id);
    if (!ql.ok) {
      return serverError_(ql.error, 'get-links', started);
    }
    
    const qrPublic = (ql.short && ql.short.public) ? 
      (ql.qr && ql.qr.public || '') : '';
    
    // Check if QR is ready
    if (qrPublic) {
      // State: READY
      return ok_({
        verifying: false,
        qrB64: qrPublic,
        url: ql.publicUrl || ''
      }, 'ready', started);
    } else {
      // State: VERIFYING (shortlink generation in progress)
      return ok_({
        verifying: true,
        qrB64: null,
        url: ql.publicUrl || ''
      }, 'verifying', started);
    }
  } catch (e) {
    return serverError_(e, 'qr-verify', started);
  }
}

// Legacy compatibility
function getShareQr(key){
  const v = getShareQrVerified(key);
  if (!v.ok) return v;
  
  return ok_({ 
    url: v.url || '', 
    qrB64:'', 
    qrUrlVerified: v.qrB64 || '' 
  }, v.phase, undefined);
}

/************************************************************
* [S13] Bundles (Display/Public/Poster) — WITH ENVELOPE
************************************************************/
function getDisplayBundle(eventIdOrSlug){
  const started = Date.now();
  
  try {
    const ev = ensureWorkbook_(eventIdOrSlug);
    if (!ev.ok) return ev;
    
    const ss = SpreadsheetApp.openById(ev.ssId);
    const meta = readKv_(ss, TABS.META);
    const cfg  = readKv_(ss, TABS.POSTER);
    
    return ok_({
      eventTag: meta.eventTag || ev.tag,
      title: meta.title || ev.name || ev.tag,
      datePretty: prettyDate_(meta.startDateISO || ev.dateISO),
      place: cfg.place || '',
      standings: readTable_(ss, TABS.STANDINGS),
      schedule:  readTable_(ss, TABS.SCHEDULE),
      adminUrl:  buildOrgUrl_('Admin', ev.id),
      publicUrl: buildPublicUrl_('Public', ev.id),
      posterPageUrl: buildPublicUrl_('Poster', ev.id)
    }, 'done', started);
  } catch (e) {
    return serverError_(e, 'display-bundle', started);
  }
}

function getPublicBundle(eventIdOrSlug, opts){
  const started = Date.now();
  
  // Rate limiting
  const rl = checkRateLimit_('read', 'public');
  if (!rl.ok) {
    return rateLimited_(
      rl.retryAfterSeconds, 
      rl.attemptNumber, 
      started
    );
  }
  
  try {
    const ev = ensureWorkbook_(eventIdOrSlug);
    if (!ev.ok) return ev;
    
    const ss = SpreadsheetApp.openById(ev.ssId);
    const meta = readKv_(ss, TABS.META);
    const cfg  = readKv_(ss, TABS.POSTER);
    
    const nameMode = String(cfg.public_name_mode || 'initials').toLowerCase();
    const standings = applyNameMode_(readTable_(ss, TABS.STANDINGS), nameMode);
    const schedule  = applyNameMode_(
      readTable_(ss, TABS.SCHEDULE),  
      nameMode, 
      ['team','team_a','team_b']
    );
    
    return ok_({
      eventTag: meta.eventTag || ev.tag,
      title: meta.title || ev.name || ev.tag,
      datePretty: prettyDate_(meta.startDateISO || ev.dateISO),
      place: cfg.place || '',
      public_name_mode: nameMode,
      standings, 
      schedule,
      posterPageUrl: buildPublicUrl_('Poster', ev.id)
    }, 'done', started);
  } catch (e) {
    return serverError_(e, 'public-bundle', started);
  }
}

function getPosterBundle(eventIdOrSlug){
  const started = Date.now();
  
  try {
    const ev = ensureWorkbook_(eventIdOrSlug);
    if (!ev.ok) return ev;
    
    const ss = SpreadsheetApp.openById(ev.ssId);
    const meta = readKv_(ss, TABS.META);
    const cfg  = readKv_(ss, TABS.POSTER);
    const posterImageUrl = String(cfg.posterImageUrl || '').trim();
    const adminUrl  = buildOrgUrl_('Admin', ev.id);
    const publicUrl = buildPublicUrl_('Public', ev.id);

    const sForm   = ev.formId ? 
      shortFor_(ev.id,'FORM', `https://docs.google.com/forms/d/${ev.formId}/viewform`) : '';
    const sPublic = shortFor_(ev.id,'PUBLIC', publicUrl);
    
    const qr = {
      form:   sForm   ? QR.image(sForm)   : '',
      public: sPublic ? QR.image(sPublic) : ''
    };

    return ok_({
      eventTag: meta.eventTag || ev.tag,
      title: meta.title || ev.name || ev.tag,
      datePretty: prettyDate_(meta.startDateISO || ev.dateISO),
      place: cfg.place || '',
      posterImageUrl,
      adminUrl, 
      publicUrl,
      qr
    }, 'done', started);
  } catch (e) {
    return serverError_(e, 'poster-bundle', started);
  }
}

/************************************************************
* [S14] Confidence / Visibility
************************************************************/
function getConfidenceState(eventIdOrSlug){
  const started = Date.now();
  
  try {
    ensureAll_();
    
    const out = {
      control: true,
      eventsHeader: true,
      event: false,
      workbook: false,
      form: false,
      posterImage: false,
      links: { public:'', display:'', posterPage:'', formView:'', workbook:'' },
      short: { public:'', display:'', poster:'', posterImage:'', posterPage:'', form:'' },
      qr:    { public:'', display:'', poster:'', posterImage:'', posterPage:'', form:'' },
      canShow: { 
        public:false, display:false, posterPage:false, 
        form:false, qrPublic:false, qrForm:false, posterImage:false 
      }
    };

    const ev = findEventByIdOrSlug_(eventIdOrSlug);
    if (!ev) return ok_(Object.assign(out, { event:false }), 'no-event', started);

    out.event = true;
    out.workbook = !!(ev.eventSpreadsheetId && ev.eventSpreadsheetUrl);
    out.form = !!ev.formId;
    out.links.workbook = ev.eventSpreadsheetUrl || '';

    if (out.workbook) {
      try {
        const book = SpreadsheetApp.openById(ev.eventSpreadsheetId);
        const posterKv = readKv_(book, TABS.POSTER);
        out.posterImage = !!String((posterKv && posterKv.posterImageUrl) || '').trim();
      } catch (_) {}

      const ql = getEventQuickLinks(ev.id);
      if (ql.ok) {
        out.links.public     = ql.publicUrl || '';
        out.links.display    = ql.displayUrl || '';
        out.links.posterPage = ql.posterPageUrl || '';
        out.links.formView   = ql.formUrlView || '';
        out.short = ql.short || {};
        out.qr    = ql.qr    || {};
      }
    }

    out.canShow.public      = !!out.links.public;
    out.canShow.display     = !!out.links.display;
    out.canShow.posterPage  = !!out.links.posterPage;
    out.canShow.form        = !!(out.form && out.links.formView);
    out.canShow.posterImage = !!out.posterImage;
    out.canShow.qrPublic    = !!(out.short && out.short.public) && 
                              !!(out.qr && out.qr.public);
    out.canShow.qrForm      = !!(out.short && out.short.form) && 
                              !!(out.qr && out.qr.form);

    return ok_(out, 'done', started);
  } catch (e) {
    return serverError_(e, 'confidence', started);
  }
}

/************************************************************
* [S15] URL Builders & Cache
************************************************************/
function buildOrgUrl_(page, eventId){   
  const base = cfgOrgUrl_();  
  return `${base}?page=${encodeURIComponent(page)}&event=${encodeURIComponent(eventId)}`; 
}

function buildPublicUrl_(page, eventId){ 
  const base = cfgPubUrl_(); 
  return `${base}?page=${encodeURIComponent(page)}&event=${encodeURIComponent(eventId)}`; 
}

function bustEventsCache_(){
  try { 
    CacheService.getScriptCache().remove('events_index'); 
  } catch(_) {}
  try { 
    PropertiesService.getScriptProperties()
      .deleteProperty(PROP.EVENTS_ETAG); 
  } catch(_) {}
}

/************************************************************
* [S16] Data Utils
************************************************************/
function findEventByIdOrSlug_(key){
  if (!key) {
    const sh = getEventsSheet_();
    const last = sh.getLastRow(); 
    if (last<2) return null;
    const rows = sh.getRange(2,1,last-1,23).getValues();
    const r = rows.find(rr => 
      String(rr[IDX.isDefault]).toLowerCase()==='true'
    );
    return r ? rowToEvent_(r) : null;
  }
  
  const sh = getEventsSheet_();
  const last = sh.getLastRow(); 
  if (last<2) return null;
  const rows = sh.getRange(2,1,last-1,23).getValues();
  const hit = rows.find(r => 
    r[IDX.id]===key || r[IDX.slug]===key
  );
  return hit ? rowToEvent_(hit) : null;
}

function ensureWorkbook_(eventIdOrSlug){
  const ev = findEventByIdOrSlug_(eventIdOrSlug);
  if (!ev) return { ok:false, error:'Eventbook not found' };
  
  if (!ev.eventSpreadsheetId){
    const r = workerCreateEventWorkbook_(ev.id);
    if (!r.ok) return r;
    ev.eventSpreadsheetId = r.spreadsheetId; 
    ev.eventSpreadsheetUrl = r.url;
  }
  
  return { 
    ok:true, 
    id:ev.id, 
    name:ev.name, 
    tag:ev.eventTag, 
    dateISO:ev.startDateISO, 
    ssId:ev.eventSpreadsheetId, 
    ssUrl:ev.eventSpreadsheetUrl, 
    formId:ev.formId 
  };
}

function workerCreateEventWorkbook_(eventId){
  ensureAll_();
  const sh = getEventsSheet_();
  const last = sh.getLastRow(); 
  if (last<2) return { ok:false, error:'No rows' };
  
  const data = sh.getRange(2,1,last-1,23).getValues();
  const idx = data.findIndex(r => r[IDX.id]===eventId);
  if (idx<0) return { ok:false, error:'Not found' };
  
  const rowNum = idx + 2;
  const r = sh.getRange(rowNum,1,1,23).getValues()[0];

  if (r[IDX.ssId] && r[IDX.ssUrl]) {
    return { ok:true, spreadsheetId: r[IDX.ssId], url: r[IDX.ssUrl] };
  }

  const name = r[IDX.name], slug = r[IDX.slug], dateISO = r[IDX.startDateISO];
  const templateId = cfgTemplateId_();
  const folderId = cfgEventsFolderId_();
  const template = DriveApp.getFileById(templateId);
  const folder = DriveApp.getFolderById(folderId);
  const newName = eventWorkbookTitle_(name, slug, dateISO, r[IDX.id]);
  const copy = template.makeCopy(newName, folder);
  const ss = SpreadsheetApp.openById(copy.getId());

  Object.values(TABS).forEach(n => { 
    if (!ss.getSheetByName(n)) ss.insertSheet(n); 
  });

  const meta = ensureKvSheet_(ss, TABS.META);
  upsertKv_(meta, {
    eventId: r[IDX.id],
    eventTag: r[IDX.tag] || computeEventTag_(slug, dateISO, r[IDX.id]),
    slug: r[IDX.slug],
    startDateISO: r[IDX.startDateISO],
    adminUrl: buildOrgUrl_('Admin', r[IDX.id]),
    publicUrl: buildPublicUrl_('Public', r[IDX.id]),
    displayUrl: buildOrgUrl_('Display', r[IDX.id]),
    posterPageUrl: buildPublicUrl_('Poster', r[IDX.id]),
    seedMode: r[IDX.seedMode] || 'random',
    elimType: r[IDX.elimType] || 'none'
  });

  header_(ss, TABS.SIGNUPS, ['timestamp','name','email','phone','team','notes']);
  header_(ss, TABS.SCHEDULE,['round','time','activity','notes','table']);
  header_(ss, TABS.STANDINGS,['team','points','tiebreak','notes']);

  sh.getRange(rowNum, IDX.ssId+1).setValue(copy.getId());
  sh.getRange(rowNum, IDX.ssUrl+1).setValue(copy.getUrl());
  bustEventsCache_();
  
  return { ok:true, spreadsheetId: copy.getId(), url: copy.getUrl() };
}

function readTable_(ss, name){
  const sh = ss.getSheetByName(name); 
  if (!sh) return [];
  
  const lr = sh.getLastRow(), lc = sh.getLastColumn();
  if (lr<2 || lc<1) return [];
  
  const vals = sh.getRange(1,1,lr,lc).getValues();
  const header = vals[0]
    .map(v => String(v||'').trim())
    .map(h => h.replace(/\s+/g,'_').toLowerCase());
  
  const out = [];
  for (let i=1;i<vals.length;i++){
    const row = {};
    for (let j=0;j<header.length;j++) {
      row[header[j]] = vals[i][j];
    }
    if (Object.values(row).every(v => v==='' || v===null)) continue;
    out.push(row);
  }
  return out;
}

function ensureKvSheet_(ss, name){
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  if (sh.getLastRow()<1) {
    sh.getRange(1,1,1,2).setValues([['key','value']]);
  }
  return sh;
}

function upsertKv_(sheet, kv){
  const lr = sheet.getLastRow();
  const rows = lr>0 ? sheet.getRange(1,1,lr,2).getValues() : [];
  const idx = {}; 
  rows.forEach((r,i)=>{ 
    const k = String(r[0]||'').trim(); 
    if(k) idx[k]=i+1; 
  });
  
  Object.entries(kv||{}).forEach(([k,v])=>{
    if (idx[k]) sheet.getRange(idx[k],2).setValue(v);
    else sheet.appendRow([k,v]);
  });
}

function header_(ss, name, cols){
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  const existing = sh.getRange(1,1,1,cols.length).getValues()[0]
    .map(v => String(v||'').trim());
  const same = existing.length===cols.length && 
               existing.every((v,i)=> v===cols[i]);
  
  if (!same) {
    sh.getRange(1,1,1,cols.length).setValues([cols]);
  }
  
  sh.setFrozenRows(1);
  sh.getRange(1,1,1,cols.length)
    .setFontWeight('bold')
    .setBackground('#f3f6fb');
  sh.autoResizeColumns(1, cols.length);
}

function posterImageFromWorkbook_(ssId){
  if (!ssId) return '';
  const ss = SpreadsheetApp.openById(ssId);
  const kv = readKv_(ss, TABS.POSTER);
  return String(kv.posterImageUrl || '').trim();
}

function readKv_(ss, name){
  const sh = ss.getSheetByName(name); 
  if (!sh) return {};
  const lr = sh.getLastRow(); 
  if (lr<1) return {};
  const vals = sh.getRange(1,1,lr,2).getValues();
  const obj = {}; 
  vals.forEach(r => { 
    const k = String(r[0]||'').trim(); 
    if (k) obj[k]=r[1]; 
  });
  return obj;
}

function applyNameMode_(rows, mode, fields){
  const m = String(mode||'initials').toLowerCase();
  if (m==='full') return rows;
  
  const targets = (fields && fields.length) ? fields : 
    ['name','team','player','team_a','team_b'];
  
  return rows.map(row=>{
    const r = Object.assign({}, row);
    targets.forEach(f=>{
      if (r[f]===undefined) return;
      const v = String(r[f]||'').trim();
      if (!v) { r[f]=v; return; }
      if (m==='none') { r[f]='—'; return; }
      const parts = v.split(/\s+/).filter(Boolean);
      r[f] = parts.map(p=>p[0]).join('').toUpperCase() || '—';
    });
    return r;
  });
}

function prettyDate_(iso){
  if (!iso) return '';
  try { 
    const d = new Date(iso); 
    return Utilities.formatDate(
      d, 
      Session.getScriptTimeZone(), 
      'EEE, MMM d — h:mma'
    ); 
  } catch (_) { 
    return String(iso); 
  }
}

/************************************************************
* [S17] Debug / Smoke
************************************************************/
function NU_Debug_ListEventbooks(){ 
  return getEventbooksSafe(null); 
}

function NU_Debug_ListEvents(){ 
  return getEventsSafe(null); 
}

function NU_Debug_GetLinks(eid){ 
  return getEventQuickLinks(eid); 
}

function NU_Debug_Display(eid){ 
  return getDisplayBundle(eid); 
}

function NU_Debug_Public(eid){ 
  return getPublicBundle(eid); 
}

function NU_Debug_Poster(eid){ 
  return getPosterBundle(eid); 
}

function runSmokeSafe(opts){
  const started = Date.now();
  
  try {
    const boot = ensureAll_();
    const evs = getEventsSafe(null);
    
    const checks = {
      controlId: boot.controlId || '',
      hasEventsSheet: !!getMain_().getSheetByName('Events'),
      itemsCount: (evs && evs.status===200 && Array.isArray(evs.items)) ? 
        evs.items.length : 0
    };
    
    return ok_({ build:BUILD_ID, checks }, 'done', started);
  } catch (e) {
    return serverError_(e, 'smoke-test', started);
  }
}

/************************************************************
* [S18] Manage Actions
************************************************************/
function setDefaultEvent(key) {
  const started = Date.now();
  
  try {
    const sh = getEventsSheet_();
    const last = sh.getLastRow();
    if (last < 2) return serverError_('no events', 'empty-sheet', started);
    
    const data = sh.getRange(2, 1, last-1, 23).getValues();
    for (let i=0;i<data.length;i++){
      const r = data[i];
      const on = (r[IDX.id]===key || r[IDX.slug]===key);
      sh.getRange(i+2, IDX.isDefault+1).setValue(!!on);
    }
    
    SpreadsheetApp.flush();
    bustEventsCache_();
    
    return ok_({}, 'done', started);
  } catch (e) {
    return serverError_(e, 'set-default', started);
  }
}

function archiveEvent(key) {
  const started = Date.now();
  
  try {
    const sh = getEventsSheet_();
    const last = sh.getLastRow();
    if (last < 2) return serverError_('no events', 'empty-sheet', started);
    
    const data = sh.getRange(2, 1, last-1, 23).getValues();
    const idx = data.findIndex(r => r[IDX.id]===key || r[IDX.slug]===key);
    if (idx < 0) return serverError_('not found', 'find-event', started);
    
    sh.deleteRow(idx + 2);
    SpreadsheetApp.flush();
    bustEventsCache_();
    
    return ok_({}, 'done', started);
  } catch (e) {
    return serverError_(e, 'archive', started);
  }
}

/************************************************************
* [S19] Template Helpers
************************************************************/
function tplEnsureSheetWithHeader_(ss, name, headers) {
  const sh = ss.getSheetByName(name) || ss.insertSheet(name);
  const have = sh.getLastRow()>=1 ? 
    sh.getRange(1,1,1,headers.length).getValues()[0] : [];
  const same = have.length===headers.length && 
               have.every((v,i)=> String(v||'')===headers[i]);
  
  if (!same) { 
    sh.clear(); 
    sh.getRange(1,1,1,headers.length).setValues([headers]); 
  }
  
  sh.setFrozenRows(1);
  sh.getRange(1,1,1,headers.length)
    .setFontWeight('bold')
    .setBackground('#f3f6fb');
  sh.autoResizeColumns(1, headers.length);
  return sh;
}

function tplUpsertKv_(sheet, kv) {
  const lr = sheet.getLastRow();
  const rows = lr>0 ? sheet.getRange(1,1,lr,2).getValues() : [];
  const idx = {}; 
  rows.forEach((r,i)=>{ 
    const k = String(r[0]||'').trim(); 
    if(k) idx[k]=i+1; 
  });
  
  Object.entries(kv||{}).forEach(([k,v])=>{
    if (idx[k]) sheet.getRange(idx[k],2).setValue(v);
    else sheet.appendRow([k,v]);
  });
}

function tplEnsureMetaKv_(ss) {
  const sh = ss.getSheetByName('Meta') || ss.insertSheet('Meta');
  if (sh.getLastRow()<1) {
    sh.getRange(1,1,1,2).setValues([['key','value']]);
  }
  
  tplUpsertKv_(sh, {
    eventId:'', eventTag:'', slug:'', startDateISO:'',
    adminUrl:'', publicUrl:'', displayUrl:'', posterPageUrl:'',
    seedMode:'random', elimType:'none'
  });
  return sh;
}

function tplEnsurePosterConfigKv_(ss) {
  const sh = ss.getSheetByName('PosterConfig') || ss.insertSheet('PosterConfig');
  if (sh.getLastRow()<1) {
    sh.getRange(1,1,1,2).setValues([['key','value']]);
  }
  
  tplUpsertKv_(sh, { 
    place:'', 
    posterImageUrl:'', 
    public_name_mode:'initials' 
  });
  return sh;
}

function ctlTemplateHeaders_(sheetName, fallback){
  try{
    const ctl = SpreadsheetApp.openById(cfgControlId_());
    const tpl = ctl.getSheetByName(sheetName);
    if (tpl && tpl.getLastRow()>=1){
      const lr = tpl.getLastRow(); 
      const lc = tpl.getLastColumn();
      const vals = tpl.getRange(1,1,Math.min(1,lr), lc).getValues()[0];
      if (vals && vals.length) return vals.map(v=>String(v||''));
    }
  } catch(_){}
  return fallback || [];
}

function ctlPosterDefaults_() {
  try{
    const ctl = SpreadsheetApp.openById(cfgControlId_());
    const sh = ctl.getSheetByName('PosterConfig');
    if (!sh) return {};
    const lr = sh.getLastRow(); 
    if (lr<2) return {};
    const vals = sh.getRange(2,1,lr-1,2).getValues();
    const obj = {}; 
    vals.forEach(r => { 
      const k = String(r[0]||'').trim(); 
      if(k) obj[k]=r[1]; 
    });
    return obj;
  } catch(_) { 
    return {}; 
  }
}

/************************************************************
* [S20] Audit
************************************************************/
function auditDeep(){
  const secs = [];
  try { secs.push(auditRouter_()); } 
    catch(e){ secs.push(sectionErr_('Router', e)); }
  try { secs.push(auditControlSheet_()); } 
    catch(e){ secs.push(sectionErr_('Control Sheet', e)); }
  try { secs.push(auditEventsCache_()); } 
    catch(e){ secs.push(sectionErr_('ETag / Cache', e)); }
  try { secs.push(auditClientFiles_()); } 
    catch(e){ secs.push(sectionErr_('Client Files', e)); }
  try { secs.push(auditProvision_()); } 
    catch(e){ secs.push(sectionErr_('Provision', e)); }

  return {
    ok: secs.every(s => s.ok),
    build: BUILD_ID,
    generatedAt: new Date().toISOString(),
    sections: secs
  };
}

function auditRouter_(){
  const checks = [];
  ['admin','public','display','poster','status','ping','r'].forEach(p=>{
    checks.push(okCheck_('route:'+p, `Route "${p}" registered`, true));
  });
  return finalizeSection_('Router', checks);
}

function auditControlSheet_(){
  const checks = [];
  const ctlId = cfgControlId_();
  const ss = SpreadsheetApp.openById(ctlId);
  const sh = ss.getSheetByName('Events');
  checks.push(okCheck_('sheet:events', 'Sheet "Events" exists', !!sh));
  
  if (sh){
    const want = [
      'id','name','slug','startDateISO','eventSpreadsheetId','eventSpreadsheetUrl',
      'formId','eventTag','isDefault','seedMode','elimType',
      'latitude','longitude','geohash','venue','city','state','country','timezone','plusCode'
    ];
    const have = sh.getRange(1,1,1,want.length).getValues()[0].map(String);
    want.forEach(h=>{
      const present = have.indexOf(h) >= 0;
      checks.push(statusCheck_(
        'hdr:'+h, 
        'Header "'+h+'" present', 
        present ? 'green':'red', 
        present ? '' : 'missing'
      ));
    });
  }
  return finalizeSection_('Control Sheet', checks);
}

function auditEventsCache_(){
  const checks = [];
  const r1 = getEventsSafe(null);
  const ok1 = !!r1 && !!r1.ok && !!r1.etag && r1.status === 200;
  checks.push(statusCheck_(
    'events:initial',
    'getEventsSafe(null) ok', 
    ok1 ? 'green':'red', 
    ok1 ? '' : JSON.stringify(r1)
  ));

  const r2 = getEventsSafe(r1 && r1.etag);
  const notMod = !!r2 && r2.ok && r2.status === 304 && 
                 r2.notModified === true && 
                 Array.isArray(r2.items) && r2.items.length === 0;
  checks.push(statusCheck_(
    'events:notmod',
    'getEventsSafe(etag) -> 304 + items:[]', 
    notMod ? 'green':'red', 
    notMod ? '' : JSON.stringify(r2)
  ));
  return finalizeSection_('ETag / Cache', checks);
}

function auditClientFiles_(){
  const mustHave = {
    'Admin':   ['#eventName','#eventDate','#elimType','#seedMode','#btnCreateEvent','#chooseEvent','#btnOpenPublic','#btnOpenTV','#btnCopyLink'],
    'Public':  ['#title','#date','#flow','#elim','#seed','#scheduleTbl','#standingsTbl','#bracketWrap'],
    'Display': ['#title','#scheduleTbl','#standingsTbl','#bracketWrap'],
    'Poster':  ['#posterTitle','#eventDate','#qrPublic','#publicUrlLabel','#qrForm','#formUrlLabel'],
    'Styles':  ['.badge','.toast','.table','.pfbar']
  };
  
  const checks = [];
  Object.keys(mustHave).forEach(name=>{
    const html = getFileContentSafe_(name);
    const present = !!html;
    checks.push(statusCheck_(
      'file:'+name, 
      `File "${name}.html" present`, 
      present ? 'green':'red', 
      present ? '' : 'missing'
    ));
    
    if (present){
      mustHave[name].forEach(sel=>{
        const found = html.indexOf(sel.replace(/"/g,'\\"')) >= 0 || 
                      html.indexOf(sel) >= 0;
        checks.push(statusCheck_(
          'sel:'+name+':'+sel, 
          `"${name}" contains selector ${sel}`, 
          found ? 'green':'red', 
          found ? '' : 'not found'
        ));
      });
    }
  });
  return finalizeSection_('Client Files', checks);
}

function auditProvision_(){
  const checks = [];
  const evs = getEventsSafe(null);
  const hasAny = evs && evs.ok && Array.isArray(evs.items) && 
                 evs.items.length > 0;
  checks.push(statusCheck_(
    'events:exists',
    'At least one event present (optional)', 
    hasAny ? 'green':'yellow', 
    hasAny ? '' : 'no events yet'
  ));

  if (hasAny){
    const first = evs.items[0];
    const s1 = provisionStep(first.id);
    checks.push(statusCheck_(
      'prov:step',
      'provisionStep returns ok', 
      (s1 && s1.ok) ? 'green':'red', 
      JSON.stringify(s1 || {})
    ));
    
    const st = getProvisionStatus(first.id);
    checks.push(statusCheck_(
      'prov:status',
      'getProvisionStatus ok', 
      (st && st.ok) ? 'green':'red', 
      JSON.stringify(st || {})
    ));
  }
  return finalizeSection_('Provision', checks);
}

function getFileContentSafe_(name){ 
  try{ 
    return HtmlService.createHtmlOutputFromFile(name).getContent(); 
  } catch(e){ 
    return ''; 
  } 
}

function okCheck_(id,label,cond){ 
  return { 
    id, label, 
    status:(cond?'green':'red'), 
    detail:(cond?'':'failed') 
  }; 
}

function statusCheck_(id,label,status,detail){ 
  return { id, label, status, detail:String(detail||'') }; 
}

function finalizeSection_(title, checks){
  const sevOrder = { red:3, yellow:2, green:1 };
  let worst = 'green';
  for (let i=0;i<checks.length;i++){ 
    const s = checks[i].status || 'green'; 
    if (sevOrder[s] > sevOrder[worst]) worst = s; 
  }
  return { 
    title, 
    ok: worst !== 'red', 
    severity: worst, 
    checks 
  };
}

function sectionErr_(title, err){
  return { 
    title, 
    ok:false, 
    severity:'red', 
    checks:[{ 
      id:'error', 
      label:title+' threw', 
      status:'red', 
      detail:String(err) 
    }] 
  };
}

/************************************************************
* [S21] Geo-Tagging Utilities
************************************************************/
function validateAndEnrichGeo_(geo) {
  if (!geo || typeof geo !== 'object') {
    return { valid: false, error: 'No geo data provided' };
  }
  
  const lat = parseFloat(geo.latitude || geo.lat);
  const lon = parseFloat(geo.longitude || geo.lon || geo.lng);
  
  if (!isFinite(lat) || !isFinite(lon)) {
    return { valid: false, error: 'Invalid coordinates' };
  }
  
  if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
    return { valid: false, error: 'Coordinates out of range' };
  }
  
  const geohash = encodeGeohash_(lat, lon, 7);
  const plusCode = encodePlusCode_(lat, lon);
  const timezone = inferTimezone_(lat, lon, geo.timezone);
  
  return {
    valid: true,
    latitude: lat,
    longitude: lon,
    geohash,
    venue: String(geo.venue || '').trim().slice(0, 200),
    city: String(geo.city || '').trim().slice(0, 100),
    state: String(geo.state || '').trim().slice(0, 50),
    country: String(geo.country || 'US').trim().toUpperCase().slice(0, 2),
    timezone,
    plusCode
  };
}

function encodeGeohash_(lat, lon, precision) {
  const BASE32 = '0123456789bcdefghjkmnpqrstuvwxyz';
  let idx = 0;
  let bit = 0;
  let evenBit = true;
  let geohash = '';
  
  let latMin = -90, latMax = 90;
  let lonMin = -180, lonMax = 180;
  
  while (geohash.length < precision) {
    if (evenBit) {
      const lonMid = (lonMin + lonMax) / 2;
      if (lon > lonMid) {
        idx = (idx << 1) + 1;
        lonMin = lonMid;
      } else {
        idx = idx << 1;
        lonMax = lonMid;
      }
    } else {
      const latMid = (latMin + latMax) / 2;
      if (lat > latMid) {
        idx = (idx << 1) + 1;
        latMin = latMid;
      } else {
        idx = idx << 1;
        latMax = latMid;
      }
    }
    evenBit = !evenBit;
    
    if (++bit === 5) {
      geohash += BASE32[idx];
      bit = 0;
      idx = 0;
    }
  }
  
  return geohash;
}

function encodePlusCode_(lat, lon) {
  const ALPHABET = '23456789CFGHJMPQRVWX';
  const LAT_MAX = 90;
  const LON_MAX = 180;
  
  lat = Math.max(-LAT_MAX, Math.min(LAT_MAX, lat));
  lon = ((lon + LON_MAX) % 360) - LON_MAX;
  
  const latVal = (lat + LAT_MAX) * 8000;
  const lonVal = (lon + LON_MAX) * 8000;
  
  let code = '';
  for (let i = 0; i < 5; i++) {
    const latDigit = Math.floor(latVal / Math.pow(20, 4 - i)) % 20;
    const lonDigit = Math.floor(lonVal / Math.pow(20, 4 - i)) % 20;
    code += ALPHABET[lonDigit] + ALPHABET[latDigit];
  }
  
  return code.slice(0, 8) + '+' + code.slice(8);
}

function inferTimezone_(lat, lon, provided) {
  if (provided) return provided;
  
  if (lat >= 24 && lat <= 50 && lon >= -125 && lon <= -66) {
    if (lon >= -125 && lon < -120) return 'America/Los_Angeles';
    if (lon >= -120 && lon < -104) return 'America/Denver';
    if (lon >= -104 && lon < -90) return 'America/Chicago';
    if (lon >= -90 && lon <= -66) return 'America/New_York';
  }
  
  return 'America/Chicago';
}

function haversineDistance_(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/**
 * Find events near a location
 * CONTRACT: findEventsNearby
 */
function findEventsNearby(opts) {
  const started = Date.now();
  
  try {
    const lat = parseFloat(opts.latitude || opts.lat);
    const lon = parseFloat(opts.longitude || opts.lon || opts.lng);
    const radiusKm = parseFloat(opts.radius || 50);
    const limit = parseInt(opts.limit || 20);
    
    if (!isFinite(lat) || !isFinite(lon)) {
      return serverError_('Invalid coordinates', 'validate-coords', started);
    }
    
    const res = getEventsSafe(null);
    if (!res.ok) return res;
    
    const geoEvents = res.items.filter(ev => 
      ev.latitude && ev.longitude
    );
    
    const withDistance = geoEvents.map(ev => ({
      ...ev,
      distanceKm: haversineDistance_(lat, lon, ev.latitude, ev.longitude)
    }));
    
    const nearby = withDistance
      .filter(ev => ev.distanceKm <= radiusKm)
      .sort((a, b) => a.distanceKm - b.distanceKm)
      .slice(0, limit);
    
    return ok_({
      query: {
        latitude: lat,
        longitude: lon,
        radiusKm
      },
      count: nearby.length,
      items: nearby.map(ev => ({
        id: ev.id,
        name: ev.name,
        slug: ev.slug,
        startDateISO: ev.startDateISO,
        venue: ev.venue,
        city: ev.city,
        state: ev.state,
        distanceKm: Math.round(ev.distanceKm * 10) / 10,
        distanceMiles: Math.round(ev.distanceKm * 0.621371 * 10) / 10,
        geohash: ev.geohash,
        publicUrl: buildPublicUrl_('Public', ev.id)
      }))
    }, 'done', started);
  } catch (e) {
    DIAG.log('error', 'findEventsNearby', 'exception', { err: String(e) });
    return serverError_(e, 'proximity-search', started);
  }
}

function findEventsInBounds(opts) {
  const started = Date.now();
  
  try {
    const bounds = {
      north: parseFloat(opts.north),
      south: parseFloat(opts.south),
      east: parseFloat(opts.east),
      west: parseFloat(opts.west)
    };
    
    if (Object.values(bounds).some(v => !isFinite(v))) {
      return serverError_('Invalid bounds', 'validate-bounds', started);
    }
    
    const res = getEventsSafe(null);
    if (!res.ok) return res;
    
    const inBounds = res.items.filter(ev => 
      ev.latitude && ev.longitude &&
      ev.latitude >= bounds.south &&
      ev.latitude <= bounds.north &&
      ev.longitude >= bounds.west &&
      ev.longitude <= bounds.east
    );
    
    return ok_({
      bounds,
      count: inBounds.length,
      items: inBounds.map(ev => ({
        id: ev.id,
        name: ev.name,
        latitude: ev.latitude,
        longitude: ev.longitude,
        venue: ev.venue,
        city: ev.city,
        publicUrl: buildPublicUrl_('Public', ev.id)
      }))
    }, 'done', started);
  } catch (e) {
    DIAG.log('error', 'findEventsInBounds', 'exception', { err: String(e) });
    return serverError_(e, 'bounds-search', started);
  }
}

// Legacy provisions shims (kept for back-compat)
function provisionStep(key){
  const started = Date.now();
  try {
    const ev = ensureWorkbook_(key);
    if (!ev.ok) return serverError_('not found', 'find-workbook', started);

    const ql = getEventQuickLinks(ev.id);
    const hasLinks = !!(ql && ql.publicUrl && ql.displayUrl);

    return ok_({
      state: hasLinks ? 'LINKS_READY' : 'WORKBOOK_READY'
    }, hasLinks ? 'links-ready' : 'workbook-ready', started);
  } catch (e) {
    DIAG.log('error','provisionStep','exception',{ err:String(e) });
    return serverError_(e, 'provision', started);
  }
}

function getProvisionStatus(key){
  const started = Date.now();
  try {
    const ev = findEventByIdOrSlug_(key);
    if (!ev) return serverError_('not found', 'find-event', started);

    const workbook = !!(ev.eventSpreadsheetId && ev.eventSpreadsheetUrl);
    if (!workbook) {
      return ok_({
        state:'CREATED', 
        hasWorkbook:false, 
        hasLinks:false
      }, 'created', started);
    }

    const ql = getEventQuickLinks(ev.id);
    const hasLinks = !!(ql && ql.publicUrl && ql.displayUrl);
    
    return ok_({
      state: hasLinks ? 'LINKS_READY' : 'WORKBOOK_READY',
      hasWorkbook: true,
      hasLinks
    }, hasLinks ? 'links-ready' : 'workbook-ready', started);
  } catch (e) {
    DIAG.log('error','getProvisionStatus','exception',{ err:String(e) });
    return serverError_(e, 'provision-status', started);
  }
}

// ==============================================
// EXPORTS FOR TESTING (GAS ignores this)
// ==============================================
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    // Add your functions here - check what functions you have
    // For example:
    ok_: typeof ok_ !== 'undefined' ? ok_ : undefined,
    serverError_: typeof serverError_ !== 'undefined' ? serverError_ : undefined,
    getProvisionStatus: typeof getProvisionStatus !== 'undefined' ? getProvisionStatus : undefined,
    getEventQuickLinks: typeof getEventQuickLinks !== 'undefined' ? getEventQuickLinks : undefined,
    
    // Add any validator/formatter/generator functions you have
    // validateEventTitle_: typeof validateEventTitle_ !== 'undefined' ? validateEventTitle_ : undefined,
    // formatDate_: typeof formatDate_ !== 'undefined' ? formatDate_ : undefined,
  };
}
