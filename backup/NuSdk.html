<script>
/* ===== NextUp v4.1.1a Â· NuSdk (client helpers) ===== */
window.NUSDK = (function(){
  const toastQ = [];
  function esc(s){ return String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  function toast(msg, type){
    const el = document.createElement('div');
    el.className = 'toast' + (type ? ' ' + type : '');
    el.textContent = String(msg || '');
    document.body.appendChild(el);
    setTimeout(()=> el.remove(), 2400);
  }
  toast.error = (m)=>toast(m,'error');
  toast.warn  = (m)=>toast(m,'warn');

  async function rpc(fn, ...args){
    return await new Promise((res, rej) =>
      google.script.run.withSuccessHandler(res).withFailureHandler(e => rej(new Error(e?.message || String(e)) ))[fn](...args)
    );
  }

  async function retry(fn, attempts, delaysMs){
    attempts = attempts || 3;
    delaysMs = delaysMs || [400, 800, 1200];
    let err;
    for (let i=0;i<attempts;i++){
      try { return await fn(); } catch(e){ err = e; }
      await new Promise(r=>setTimeout(r, delaysMs[Math.min(i, delaysMs.length-1)]));
    }
    throw err || new Error('retry_failed');
  }

  return { rpc, retry, toast, esc };
})();

/* ===== Contract Validation (Client-Side) ===== */
window.NUSDK.contracts = {
  /**
   * Validate RPC response against expected contract
   * Usage: NUSDK.contracts.validate('getEventsSafe', response)
   */
  validate(contractName, response) {
    const validators = {
      getEventsSafe: (r) => {
        const errors = [];
        if (!r || typeof r !== 'object') errors.push('Response not an object');
        if (typeof r.ok !== 'boolean') errors.push('Missing field: ok');
        if (![200, 304, 500].includes(r.status)) errors.push(`Invalid status: ${r.status}`);
        if (typeof r.etag !== 'string') errors.push('Missing field: etag');
        if (typeof r.notModified !== 'boolean') errors.push('Missing field: notModified');
        if (!Array.isArray(r.items)) errors.push('Missing field: items (array)');
        
        // Status-specific validation
        if (r.status === 304 && r.items.length > 0) {
          errors.push('Status 304 should have empty items array');
        }
        if (r.status === 200 && r.notModified === true) {
          errors.push('Status 200 should have notModified=false');
        }
        
        return errors;
      },
      
      findEventsNearby: (r) => {
        const errors = [];
        if (!r || typeof r !== 'object') errors.push('Response not an object');
        if (typeof r.ok !== 'boolean') errors.push('Missing field: ok');
        if (typeof r.count !== 'number') errors.push('Missing field: count');
        if (!Array.isArray(r.items)) errors.push('Missing field: items (array)');
        if (r.count !== r.items.length) errors.push(`count (${r.count}) !== items.length (${r.items.length})`);
        
        // Validate items are sorted by distance
        for (let i = 1; i < r.items.length; i++) {
          if (r.items[i].distanceKm < r.items[i-1].distanceKm) {
            errors.push(`Items not sorted: item ${i} distance ${r.items[i].distanceKm} < previous ${r.items[i-1].distanceKm}`);
            break;
          }
        }
        
        return errors;
      },
      
      getPublicBundleMobile: (r) => {
        const errors = [];
        if (!r || typeof r !== 'object') errors.push('Response not an object');
        if (typeof r.ok !== 'boolean') errors.push('Missing field: ok');
        if (!Array.isArray(r.standings)) errors.push('Missing field: standings (array)');
        if (!Array.isArray(r.schedule)) errors.push('Missing field: schedule (array)');
        if (!r.pagination || typeof r.pagination !== 'object') errors.push('Missing field: pagination');
        
        // Validate pagination
        if (r.pagination) {
          if (typeof r.pagination.limit !== 'number') errors.push('pagination.limit not a number');
          if (typeof r.pagination.offset !== 'number') errors.push('pagination.offset not a number');
          if (typeof r.pagination.hasMore !== 'boolean') errors.push('pagination.hasMore not a boolean');
        }
        
        // Validate geo if present
        if (r.geo && r.geo.proximity) {
          if (typeof r.geo.proximity.distanceKm !== 'number') {
            errors.push('geo.proximity.distanceKm not a number');
          }
          if (typeof r.geo.proximity.distanceMiles !== 'number') {
            errors.push('geo.proximity.distanceMiles not a number');
          }
        }
        
        return errors;
      }
    };
    
    const validator = validators[contractName];
    if (!validator) {
      console.warn(`[Contracts] No validator for ${contractName}`);
      return { valid: true, errors: [] };
    }
    
    const errors = validator(response);
    const valid = errors.length === 0;
    
    if (!valid) {
      console.error(`[Contracts] ${contractName} validation failed:`, errors);
      // Send to monitoring
      if (window.NUSDK.monitoring) {
        window.NUSDK.monitoring.logContractViolation(contractName, errors);
      }
    }
    
    return { valid, errors };
  }
};

/* ===== Geo-Location Helper ===== */
window.NUSDK.geo = {
  /**
   * Get user's current position (mobile-first)
   * Returns high-accuracy position with timeout
   */
  async getCurrentPosition() {
    if (!navigator.geolocation) {
      return { error: 'Geolocation not supported' };
    }
    
    return new Promise((resolve) => {
      const options = {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 30000 // Cache for 30s
      };
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy,
            timestamp: position.timestamp
          });
        },
        (error) => {
          resolve({ error: error.message });
        },
        options
      );
    });
  },
  
  /**
   * Calculate distance between two points (Haversine)
   * Returns km and miles
   */
  distance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Earth radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    const km = R * c;
    
    return {
      km: Math.round(km * 10) / 10,
      miles: Math.round(km * 0.621371 * 10) / 10
    };
  }
};

/* ===== Network Information API (Mobile) ===== */
window.NUSDK.network = {
  /**
   * Get connection type for adaptive loading
   * Returns: 'slow-2g' | '2g' | '3g' | '4g' | 'wifi' | 'unknown'
   */
  getConnectionType() {
    if (!navigator.connection) return 'unknown';
    
    const conn = navigator.connection;
    const type = conn.effectiveType || 'unknown';
    
    // Map to our contract types
    const mapping = {
      'slow-2g': 'slow-2g',
      '2g': '2g',
      '3g': '3g',
      '4g': '4g'
</script>