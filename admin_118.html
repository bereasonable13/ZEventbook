<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>
        <?= appTitle ?> · Admin
    </title>
    <?!= include('Styles'); ?>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
</head>

<body>
    <main class="container">
        <header>
            <h1>NextUp Admin</h1>
            <small id="build">BUILD:
                <?= BUILD_ID ?>
            </small>
        </header>

        <!-- Create Eventbook -->
        <section aria-label="Create Event">
            <h2>Create Eventbook</h2>
            <div class="form-grid">
                <label>Event name
                    <input id="eventName" type="text" placeholder="e.g., Fall League Night 1" />
                </label>
                <label>Start date
                    <input id="eventDate" type="date" />
                </label>
                <label>Elimination
                    <select id="elimType">
                        <option value="single">Single</option>
                        <option value="double">Double</option>
                        <option value="round-robin">Round Robin</option>
                    </select>
                </label>
                <label>Seeding
                    <select id="seedMode">
                        <option value="seeded">Seeded</option>
                        <option value="random">Random</option>
                        <option value="none">None</option>
                    </select>
                </label>
            </div>
            <div class="actions">
                <button id="btnCreateEvent" class="btn btn-xl">Create</button>
            </div>
        </section>

        <!-- Manage Eventbooks -->
        <section aria-label="Manage Events">
            <h2>Manage Eventbooks</h2>
            <div class="row">
                <label for="chooseEvent" id="eventMeta">Choose eventbook</label>
                <select id="chooseEvent"></select>
                <button id="btnRefreshEvents" class="btn">Refresh</button>
            </div>

            <div class="row gap">
                <button id="btnOpenPublic" class="btn" disabled data-reason="Preparing…">Open Public</button>
                <button id="btnOpenTV" class="btn" disabled data-reason="Preparing…">Open Display (TV)</button>
                <button id="btnCopyLink" class="btn" disabled data-reason="Preparing…">Copy Public Link</button>
            </div>
        </section>

        <!-- Diagnostics (collapsible) -->
        <section id="diagPane" class="diag collapsed" aria-label="Diagnostics">
            <header class="diag-head">
                <button id="diagToggle" class="btn">Diagnostics ▸</button>
                <div class="diag-actions">
                    <label class="diag-checkbox"><input type="checkbox" id="diagAutoscroll" checked> Autoscroll</label>
                    <button id="diagCopy" class="btn">Copy</button>
                    <button id="diagClear" class="btn">Clear</button>
                </div>
            </header>
            <pre id="diagBody" class="diag-body" aria-live="polite"></pre>
        </section>
    </main>

    <!-- Toast host -->
    <div id="toast" class="toast" style="display:none;"></div>

    <script>
        /* ================= Admin v4.1 (hardened) ================= */

        /** 0) Config + feature flags (centralized) */
        const CONFIG = {
            POLL: { workbook: { step: 800, timeout: 15000 }, links: { step: 1000, timeout: 20000 } },
            TOAST_MS: 3200,
            RETRY: { netBackoff: [600, 1200, 2500] },
            FEATURE: { diag: true, bgProvisionWatch: true },
            STORAGE_KEYS: { selected: 'nu_selected_event', logLevel: 'nu_log' }
        };
        const BUILD = 'ADMIN v4.1';
        const STATUS = { CREATED: 'CREATED', WORKBOOK_READY: 'WORKBOOK_READY', LINKS_READY: 'LINKS_READY', ERROR: 'ERROR' };

        /** 1) Diagnostics + logger with levels */
        const LOG_LEVEL = localStorage.getItem(CONFIG.STORAGE_KEYS.logLevel) || 'info'; // 'info'|'warn'|'error'|'none'
        function allow(level) { const ord = { none: 0, error: 1, warn: 2, info: 3 }; return ord[level] <= ord[LOG_LEVEL]; }

        function diagInit() {
            const pane = document.querySelector('#diagPane');
            const body = document.querySelector('#diagBody');
            const toggle = document.querySelector('#diagToggle');
            const copyBtn = document.querySelector('#diagCopy');
            const clearBtn = document.querySelector('#diagClear');
            const auto = document.querySelector('#diagAutoscroll');
            if (!pane || !body) return;

            toggle?.addEventListener('click', () => {
                const isCollapsed = pane.classList.toggle('collapsed');
                toggle.textContent = isCollapsed ? 'Diagnostics ▸' : 'Diagnostics ▾';
                if (!isCollapsed && DIAG_AUTOSCROLL) body.scrollTop = body.scrollHeight;
            });
            copyBtn?.addEventListener('click', async () => {
                const txt = Array.from(body.querySelectorAll('div')).map(d => d.textContent).join('\n');
                try { await navigator.clipboard.writeText(txt); toast('Diagnostics copied'); } catch { toast('Copy failed', 'error'); }
            });
            clearBtn?.addEventListener('click', () => { body.innerHTML = ''; });
            auto?.addEventListener('change', (e) => { DIAG_AUTOSCROLL = !!e.target.checked; });
            pane.classList.add('collapsed');
        }
        const DIAG_MAX_LINES = 400; let DIAG_AUTOSCROLL = true;
        function tstamp() { return new Date().toISOString().replace('T', ' ').replace('Z', ''); }
        function dlog(level, ...parts) {
            if (!allow(level)) return;
            const body = document.querySelector('#diagBody');
            if (!body) return;
            const div = document.createElement('div');
            div.className = `lvl-${level}`;
            const safe = (p) => typeof p === 'string' ? p : (function () { try { return JSON.stringify(p) } catch { return String(p) } })();
            div.textContent = [BUILD, tstamp(), level.toUpperCase(), ...parts.map(safe)].join(' | ');
            body.appendChild(div);
            while (body.children.length > DIAG_MAX_LINES) body.removeChild(body.firstChild);
            if (DIAG_AUTOSCROLL && !document.querySelector('#diagPane').classList.contains('collapsed')) {
                body.scrollTop = body.scrollHeight;
            }
        }
        const log = (...a) => { if (allow('info')) console.log(BUILD, '|', ...a); dlog('info', ...a); };
        const warn = (...a) => { if (allow('warn')) console.warn(BUILD, '|', ...a); dlog('warn', ...a); };
        const error = (...a) => { if (allow('error')) console.error(BUILD, '|', ...a); dlog('error', ...a); };

        /** 2) DOM refs (defensive) */
        const els = {
            name: document.querySelector('#eventName'),
            date: document.querySelector('#eventDate'),
            elim: document.querySelector('#elimType'),
            seed: document.querySelector('#seedMode'),
            btnCreate: document.querySelector('#btnCreateEvent'),
            sel: document.querySelector('#chooseEvent'),
            btnRefresh: document.querySelector('#btnRefreshEvents'),
            btnPublic: document.querySelector('#btnOpenPublic'),
            btnTV: document.querySelector('#btnOpenTV'),
            btnCopy: document.querySelector('#btnCopyLink'),
            toast: document.querySelector('#toast')
        };
        function ensure(el, id) { if (!el) throw new Error(`Missing #${id}`); return el; }
        ['name', 'date', 'elim', 'seed', 'btnCreate', 'sel', 'btnRefresh', 'btnPublic', 'btnTV', 'btnCopy', 'toast'].forEach(k => ensure(els[k], k));

        /** 3) Toasts (uniform) */
        function showToast(msg, type = 'info', ms = CONFIG.TOAST_MS) {
            const t = els.toast; if (!t) return;
            t.textContent = msg;
            t.className = (type === 'error' ? 'toast error' : type === 'warn' ? 'toast warn' : 'toast');
            t.style.display = 'block';
            if (type !== 'error') setTimeout(() => (t.style.display = 'none'), ms);
        }
        const toast = showToast;
        const toastCreating = () => toast('Creating event…');
        const toastCreatingBook = () => toast('Creating eventbook…');
        const toastBookReady = () => toast('Eventbook ready — preparing links…');
        const toastLinksReady = () => toast('Links ready — open Public/Display now.');

        /** 4) RPC (hardened + offline awareness) */
        async function rpc(fn, ...args) {
            try {
                return await new Promise((res, rej) =>
                    google.script.run.withSuccessHandler(res).withFailureHandler(e => rej(new Error(e?.message || String(e))))[fn](...args)
                );
            } catch (err) {
                if (!navigator.onLine) throw new Error('offline');
                throw err;
            }
        }
        const api = {
            getEventsSafe: (etag) => rpc('getEventsSafe', etag || null),
            createEvent: (payload) => rpc('createEvent', payload),
            provisionStep: (key) => rpc('provisionStep', key),
            getProvisionStatus: (key) => rpc('getProvisionStatus', key),
            ping: () => rpc('ping')
        };

        /** 5) SWR state + selection persistence */
        const swr = { etag: null, items: Object.freeze([]), selectedKey: localStorage.getItem(CONFIG.STORAGE_KEYS.selected) || null, syncing: false };
        let BOOT = { firstLoad: true, bootToastShown: false };
        let INFLIGHT = { create: false, stage: false };
        let BG_WATCH = { timer: null };

        function setSyncBadge(on) {
            const label = document.querySelector('label[for="chooseEvent"]') || document.querySelector('#eventMeta');
            if (!label) return; const attr = 'data-sync'; if (on) label.setAttribute(attr, 'syncing'); else label.removeAttribute(attr);
        }
        function currentEvent() {
            const k = swr.selectedKey; if (!k) return null;
            return swr.items.find(r => r.id === k || r.slug === k) || null;
        }
        function updateShareButtons() {
            const ev = currentEvent();
            const disableWith = (msg) => [els.btnPublic, els.btnTV, els.btnCopy].forEach(b => { b.disabled = true; b.setAttribute('data-reason', msg); });
            const enableAll = () => [els.btnPublic, els.btnTV, els.btnCopy].forEach(b => { b.disabled = false; b.removeAttribute('data-reason'); });
            if (!ev) return disableWith('No event selected');
            if (ev.status === STATUS.CREATED) return disableWith('Preparing workbook…');
            if (ev.status === STATUS.WORKBOOK_READY) return disableWith('Preparing links…');
            const publicUrl = ev.publicUrl || ev.eventPublicUrl;
            const displayUrl = ev.displayUrl || ev.eventDisplayUrl;
            (publicUrl && displayUrl) ? enableAll() : disableWith('Preparing links…');
        }
        function selectByKey(key) {
            const opts = Array.from(els.sel.options);
            const idx = opts.findIndex(o => o.value === key);
            els.sel.selectedIndex = (idx >= 0 ? idx : 0);
            swr.selectedKey = els.sel.value || null;
            localStorage.setItem(CONFIG.STORAGE_KEYS.selected, swr.selectedKey || '');
        }
        function renderEvents(items, desiredKey = null) {
            const options = [];
            if (!items || !items.length) {
                options.push(new Option('No events yet — create one above', ''));
                els.sel.replaceChildren(...options);
                updateShareButtons(); return;
            }
            items.forEach(ev => {
                const label = ev.name?.trim() || ev.slug || ev.id || '(unnamed)';
                const tag = ev.eventTag ? ` · ${ev.eventTag}` : '';
                const status = ev.status && ev.status !== STATUS.LINKS_READY ? ` [${ev.status}]` : '';
                const o = new Option(`${label}${tag}${status}`, ev.id || ev.slug);
                o.title = `${label}${tag}`;
                options.push(o);
            });
            const current = desiredKey || swr.selectedKey || (items[0]?.id || items[0]?.slug);
            els.sel.replaceChildren(...options);
            selectByKey(current);
            updateShareButtons();
        }

        /** 6) Input validation + humanized errors */
        function payloadFromForm() {
            const name = (els.name.value || '').trim();
            if (!name) throw new Error('Please enter an event name.');
            const startDateISO = (els.date.value || '').trim() || new Date().toISOString().slice(0, 10);
            const elimType = els.elim.value || 'single';
            const seedMode = els.seed.value || 'seeded';
            return { name, startDateISO, elimType, seedMode, slug: '' };
        }
        function humanize(err) {
            const m = String(err || '').toLowerCase();
            if (m.includes('offline')) return 'You’re offline. Showing last known data.';
            if (m.includes('quota')) return 'Google quota—try again shortly.';
            if (m.includes('permission')) return 'No permission to the event workbook.';
            if (m.includes('not found')) return 'Workbook not found (was it deleted?).';
            if (m.includes('timed out')) return 'Provisioning is slow—will keep trying.';
            return String(err || 'Unexpected error');
        }

        /** 7) SWR loader (never blank; freeze copies) */
        async function syncEvents() {
            if (swr.syncing) return;
            swr.syncing = true; setSyncBadge(true);
            try {
                if (BOOT.firstLoad && !BOOT.bootToastShown) { toast('Loading eventbooks…'); BOOT.bootToastShown = true; }
                const res = await api.getEventsSafe(swr.etag);
                if (res.notModified) { log('SWR not modified'); return; }
                if (!res.ok) throw new Error(res.error || 'events load failed');
                const prevSel = swr.selectedKey;
                swr.etag = res.etag || null;
                swr.items = Object.freeze((res.items || []).map(o => ({ ...o })));
                renderEvents(swr.items, prevSel);
                log('SWR updated', { n: swr.items.length, sel: swr.selectedKey });
                if (BOOT.firstLoad) { toast(`Loaded ${swr.items.length} eventbook${swr.items.length === 1 ? '' : 's'}.`); BOOT.firstLoad = false; }
            } catch (e) {
                error('SWR error', e);
                toast(humanize(e), 'error');
                // backoff retries a couple of times
                for (const ms of CONFIG.RETRY.netBackoff) {
                    await new Promise(r => setTimeout(r, ms));
                    try { await api.getEventsSafe(swr.etag); break; } catch { }
                }
            } finally {
                swr.syncing = false; setSyncBadge(false);
            }
        }

        /** 8) Create + staging (idempotent; background watcher on timeout) */
        function optimisticInsert(item) {
            const key = item.id || item.slug;
            const idx = swr.items.findIndex(r => r.id === key || r.slug === key);
            const updated = idx >= 0 ? swr.items.map((r, i) => i === idx ? { ...r, ...item } : r) : [{ ...item }, ...swr.items];
            swr.items = Object.freeze(updated);
            renderEvents(swr.items, key);
        }
        function pollUntil(fn, { step, timeout }) {
            const start = Date.now();
            return new Promise((resolve, reject) => {
                const tick = async () => {
                    try {
                        const done = await fn();
                        if (done) return resolve(true);
                        if (Date.now() - start > timeout) return reject(new Error('timed out'));
                        setTimeout(tick, step);
                    } catch (e) { return reject(e); }
                };
                tick();
            });
        }
        function startBgProvisionWatch(key) {
            if (!CONFIG.FEATURE.bgProvisionWatch) return;
            clearInterval(BG_WATCH.timer);
            BG_WATCH.timer = setInterval(async () => {
                try {
                    await api.provisionStep(key);
                    const s = await api.getProvisionStatus(key);
                    if (s.status === STATUS.LINKS_READY) {
                        clearInterval(BG_WATCH.timer);
                        toast('Links ready.');
                        syncEvents();
                    }
                } catch { }
            }, 3000);
        }
        async function stageProvision(key) {
            // Phase 1: wait for WORKBOOK_READY or LINKS_READY
            await pollUntil(async () => {
                await api.provisionStep(key);
                const s = await api.getProvisionStatus(key);
                if (!s.ok) throw new Error(s.error || 'status failed');
                if (s.status === STATUS.ERROR) throw new Error(s.statusMsg || 'Provision error');
                if (s.status === STATUS.WORKBOOK_READY) { toastBookReady(); return true; }
                if (s.status === STATUS.LINKS_READY) { toastLinksReady(); return true; }
                return false;
            }, CONFIG.POLL.workbook);

            // Phase 2: LINKS_READY (warn on timeout, keep watching in background)
            try {
                await pollUntil(async () => {
                    await api.provisionStep(key);
                    const s = await api.getProvisionStatus(key);
                    if (s.status === STATUS.ERROR) throw new Error(s.statusMsg || 'Provision error');
                    return s.status === STATUS.LINKS_READY;
                }, CONFIG.POLL.links);
                toastLinksReady();
            } catch (e) {
                warn('Phase2 timeout; enabling background watch', e);
                toast(humanize('timed out'), 'warn');
                startBgProvisionWatch(key);
            }
        }

        async function onCreateClicked() {
            if (INFLIGHT.create || INFLIGHT.stage) return;
            try {
                // 1) Validate
                let payload;
                try { payload = payloadFromForm(); }
                catch (vErr) { toast(vErr.message || String(vErr), 'error'); return; }

                // 2) Create
                INFLIGHT.create = true;
                toastCreating();
                const res = await api.createEvent(payload);
                if (!res.ok) throw new Error(res.error || 'Create failed');
                const item = res.item;
                optimisticInsert(item);
                toastCreatingBook();

                // 3) Stage provision
                INFLIGHT.stage = true;
                await stageProvision(item.id || item.slug);
                INFLIGHT.stage = false;

                // 4) Reconcile once
                syncEvents();
            } catch (e) {
                error('Create/stage error', e);
                toast(humanize(e), 'error');
            } finally {
                INFLIGHT.create = false;
            }
        }

        /** 9) Wire up UI */
        function onChangeEventSel() { swr.selectedKey = els.sel.value; localStorage.setItem(CONFIG.STORAGE_KEYS.selected, swr.selectedKey || ''); updateShareButtons(); }
        function onRefreshClicked() { syncEvents(); }
        document.addEventListener('DOMContentLoaded', () => {
            try { diagInit(); } catch { }
            log('BOOT start');

            els.btnCreate?.addEventListener('click', onCreateClicked);
            els.sel?.addEventListener('change', onChangeEventSel);
            els.btnRefresh?.addEventListener('click', onRefreshClicked);

            els.btnPublic?.addEventListener('click', () => {
                const ev = currentEvent(); if (!ev) return;
                const url = ev.publicUrl || ev.eventPublicUrl; if (url) window.open(url, '_blank');
            });
            els.btnTV?.addEventListener('click', () => {
                const ev = currentEvent(); if (!ev) return;
                const url = ev.displayUrl || ev.eventDisplayUrl; if (url) window.open(url, '_blank');
            });
            els.btnCopy?.addEventListener('click', async () => {
                const ev = currentEvent(); if (!ev) return;
                const url = ev.publicUrl || ev.eventPublicUrl; if (!url) return;
                try { await navigator.clipboard.writeText(url); toast('Public link copied'); } catch { toast('Copy failed', 'error'); }
            });

            // initial load + periodic refresh
            syncEvents();
            setInterval(syncEvents, 15000);
        });
    </script>
</body>

</html>