<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>
        <?= appTitle ?> · Poster
    </title>
    <?!= include('Styles'); ?>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <style>
        .poster {
            max-width: 840px;
            margin: 0 auto;
            padding: 16px;
        }

        .qrgrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .qrbox {
            border: 1px solid rgba(0, 0, 0, .12);
            border-radius: 8px;
            padding: 12px;
            background: #fff;
        }

        .qrbox img {
            display: block;
            width: 100%;
            height: auto;
        }

        .qr-fallback {
            font-size: .9rem;
            word-break: break-all;
            color: #333;
        }

        .meta small {
            color: #555;
        }

        @media print {
            .pfbar {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <main class="poster">
        <header>
            <h1 id="posterTitle">(event)</h1>
            <div class="meta">
                <small id="eventDate"></small>
                <span id="statusBadge" style="margin-left:8px;"></span>
            </div>
        </header>

        <section class="qrgrid">
            <div class="qrbox">
                <h3>Public Page</h3>
                <div id="qrPublic">
                    <div class="spinner" aria-label="Loading QR"></div>
                </div>
                <small id="publicUrlLabel"></small>
            </div>
            <div class="qrbox">
                <h3>Signups (Form)</h3>
                <div id="qrForm">
                    <div class="spinner" aria-label="Loading Form link"></div>
                </div>
                <small id="formUrlLabel"></small>
            </div>
        </section>

        <p><em>Tip:</em> If a QR isn’t ready yet, this poster keeps checking and fills it automatically.</p>
    </main>

    <script>
        /* ================= Poster v4.1 ================= */

        /** 0) Config (centralized) */
        const CONFIG = {
            META_RETRY_MS: [1200, 2000, 3000], // backoff if meta fails
            QR_RETRY_MS: [1500, 2500, 4000], // backoff if QR not ready
            LOOP_FORM_MS: 4000 // periodic form URL recheck until available
        };

        /** 1) Params */
        const params = new URLSearchParams(location.search);
        const eventKey = params.get('event') || '';

        /** 2) RPC (hardened + offline awareness) */
        async function rpc(fn, ...args) {
            try {
                return await new Promise((res, rej) =>
                    google.script.run.withSuccessHandler(res).withFailureHandler(e => rej(new Error(e?.message || String(e))))[fn](...args)
                );
            } catch (err) {
                if (!navigator.onLine) throw new Error('offline');
                throw err;
            }
        }

        /** 3) DOM (defensive) */
        const els = {
            title: document.getElementById('posterTitle'),
            date: document.getElementById('eventDate'),
            badge: document.getElementById('statusBadge'),
            qrPub: document.getElementById('qrPublic'),
            qrForm: document.getElementById('qrForm'),
            pubLabel: document.getElementById('publicUrlLabel'),
            formLabel: document.getElementById('formUrlLabel')
        };
        function must(el, id) { if (!el) throw new Error('Missing #' + id); return el; }
        ['title', 'date', 'badge', 'qrPub', 'qrForm', 'pubLabel', 'formLabel'].forEach(k => must(els[k], k));

        /** 4) Utils */
        function esc(s) { return String(s ?? '').replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c])); }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        /** 5) Meta loader (name/date/status) with small backoff on errors */
        async function loadMeta() {
            let attempt = 0;
            while (true) {
                try {
                    const r = await rpc('getPublicBundle', eventKey);
                    if (!r || !r.ok) throw new Error(r?.error || 'meta load failed');

                    const m = r.eventMeta || {};
                    els.title.textContent = m.name || '(event)';
                    els.date.textContent = m.dateISO || '';
                    if (!m.status || m.status === 'LINKS_READY') els.badge.innerHTML = '';
                    else {
                        const text = (m.status === 'CREATED') ? 'Preparing workbook…' : 'Preparing links…';
                        els.badge.innerHTML = `<span class="badge badge-warn">${text}</span>`;
                    }
                    return; // success
                } catch (e) {
                    if (String(e || '').includes('offline')) {
                        els.badge.innerHTML = `<span class="badge badge-warn">Offline — showing cached view</span>`;
                    }
                    const backoff = CONFIG.META_RETRY_MS[Math.min(attempt, CONFIG.META_RETRY_MS.length - 1)];
                    attempt++;
                    await sleep(backoff);
                }
            }
        }

        /** 6) Public QR loader (keeps retrying until ready) */
        async function loadPublicQr() {
            let attempt = 0;
            while (true) {
                try {
                    const r = await rpc('getShareQr', eventKey);
                    if (!r || !r.ok) throw new Error(r?.error || 'not ready');

                    const url = r.url || '';
                    els.pubLabel.textContent = url;
                    if (r.qrB64) {
                        els.qrPub.innerHTML = `<img alt="Public QR" src="data:image/png;base64,${r.qrB64}" />`;
                    } else {
                        els.qrPub.innerHTML = `<div class="qr-fallback">${esc(url)}</div>`;
                    }
                    return; // success
                } catch (_e) {
                    const backoff = CONFIG.QR_RETRY_MS[Math.min(attempt, CONFIG.QR_RETRY_MS.length - 1)];
                    attempt++;
                    await sleep(backoff);
                }
            }
        }

        /** 7) Form URL loader (polls periodically until present) */
        let formLoopTimer = null;
        async function loadFormUrlOnce() {
            try {
                const r = await rpc('getPublicBundle', eventKey);
                if (!r || !r.ok) throw new Error(r?.error || 'bundle load failed');

                const formUrl = (r.eventMeta && r.eventMeta.formUrl) || '';
                if (formUrl) {
                    els.formLabel.textContent = formUrl;
                    els.qrForm.innerHTML = `<div class="qr-fallback">${esc(formUrl)}</div>`;
                    if (formLoopTimer) { clearInterval(formLoopTimer); formLoopTimer = null; }
                }
            } catch (_e) {
                // Quietly ignore; next tick will try again
            }
        }

        /** 8) Boot */
        document.addEventListener('DOMContentLoaded', async () => {
            // Start all tasks in parallel
            loadMeta();
            loadPublicQr();
            loadFormUrlOnce();
            formLoopTimer = setInterval(loadFormUrlOnce, CONFIG.LOOP_FORM_MS); // keep checking until present
        });
    </script>
</body>

</html>