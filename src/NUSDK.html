<script>
/**
 * NextUp SDK - Client-side RPC wrapper
 * Provides a clean interface for calling Apps Script server functions
 * with automatic rate limit handling
 */
window.NU = (function() {
  'use strict';

  /**
   * Call a server-side function with rate limit handling
   * @param {string} method - Function name
   * @param {...any} args - Function arguments
   * @returns {Promise} - Resolves with function result
   */
  function rpc(method, ...args) {
    return new Promise((resolve, reject) => {
      const startTime = performance.now();
      let retryCount = 0;
      const maxRetries = 2;
      
      function attemptCall() {
        google.script.run
          .withSuccessHandler(result => {
            const duration = performance.now() - startTime;
            console.log(`[NU] ${method} ✓ ${duration.toFixed(0)}ms`, result);
            
            // Check for rate limit in response
            if (result && result.code === 429) {
              if (retryCount < maxRetries) {
                retryCount++;
                const waitTime = 5000 * retryCount; // 5s, 10s
                console.warn(`[NU] ${method} rate limited, retry ${retryCount}/${maxRetries} in ${waitTime}ms`);
                setTimeout(attemptCall, waitTime);
              } else {
                resolve(result); // Return rate limit response
              }
            } else {
              resolve(result);
            }
          })
          .withFailureHandler(error => {
            const duration = performance.now() - startTime;
            const errorStr = String(error);
            
            // Check for rate limit
            const isRateLimit = errorStr.includes('429') || 
                               errorStr.includes('Rate limit') ||
                               errorStr.includes('Too Many Requests');
            
            if (isRateLimit && retryCount < maxRetries) {
              retryCount++;
              const waitTime = 5000 * retryCount;
              console.warn(`[NU] ${method} rate limited, retry ${retryCount}/${maxRetries} in ${waitTime}ms`);
              setTimeout(attemptCall, waitTime);
            } else {
              console.error(`[NU] ${method} ✗ ${duration.toFixed(0)}ms`, error);
              reject(error);
            }
          })
          [method](...args);
      }
      
      attemptCall();
    });
  }

  /**
   * Log to server
   * @param {string} level - Log level (info, warn, error)
   * @param {string} where - Location/context
   * @param {string} msg - Message
   * @param {any} data - Optional data
   */
  function log(level, where, msg, data) {
    const entry = {
      level: level || 'info',
      where: where || 'client',
      msg: msg || '',
      data: data,
      ts: Date.now()
    };

    // Don't wait for response, and don't retry on failure
    rpc('clientLog', entry).catch(() => {});
  }

  /**
   * Get current build info
   */
  function getBuildInfo() {
    const buildEl = document.getElementById('build');
    return buildEl ? buildEl.textContent : 'unknown';
  }

  // Public API
  return {
    rpc,
    log,
    getBuildInfo,
    
    // Convenience methods
    info: (where, msg, data) => log('info', where, msg, data),
    warn: (where, msg, data) => log('warn', where, msg, data),
    error: (where, msg, data) => log('error', where, msg, data)
  };
})();
</script>
