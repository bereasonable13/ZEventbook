<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title><?= appTitle ?> · Test & SLA</title>
  <?!= include('Styles'); ?>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    /* reorg for better maintenance */
    /* Test-only extras */
    .grid-2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); font-weight:700; }
    .g { background: var(--ok-bg); color: var(--ok); }
    .y { background: var(--warn-bg); color: var(--warn); }
    .r { background: var(--err-bg); color: var(--err); }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    .kvs { display:grid; grid-template-columns: 220px 1fr; gap:6px 10px; }
    .kvs div { padding:6px 0; border-bottom:1px dashed var(--line); }
    .small { font-size:.9rem; color: #444; }
    .btn-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .muted { color: var(--muted); }
    .status-dot { width:10px; height:10px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:6px; background:#bbb; }
    .status-dot.g { background:#1e7f54; }
    .status-dot.y { background:#b07a00; }
    .status-dot.r { background:#a61c1c; }
    .card-head { display:flex; justify-content:space-between; gap:8px; align-items:center; }
    .code { background:#0d1117; color:#c9d1d9; border:1px solid #30363d; border-radius:8px; padding:8px; overflow:auto; max-height:280px; }
    .nowrap { white-space: nowrap; }
    .section-sub { margin-top:.25rem; color:#555; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Test & SLA</h1>
      <div class="meta">
        <span class="muted">Build:</span> <code id="buildId" class="mono"><?= BUILD_ID ?></code>
      </div>
      <small class="muted">All tests are safe in prod; mock keys are used unless you provide a real event key.</small>
    </header>

    <!-- ================= Preflight (quick sanity) ================= -->
    <section data-testid="test-preflight">
      <div class="card-head">
        <h2>Preflight</h2>
        <div class="btn-row">
          <button class="btn" id="btnRunSmoke" data-testid="btn-smoke">Run Smoke</button>
          <button class="btn" id="btnRunSelfTests" data-testid="btn-selftests">Run API Contracts</button>
        </div>
      </div>
      <div class="row small">
        <span><span id="pf-ctrl-dot" class="status-dot"></span>Control</span>
        <span><span id="pf-tpl-dot" class="status-dot"></span>Template</span>
        <span><span id="pf-qr-dot" class="status-dot"></span>QR Cache</span>
      </div>
      <div id="preflightMsg" class="small muted" style="margin-top:6px;"></div>
    </section>

    <!-- ================= SLA Matrix Runner (8 scenarios) ================= -->
    <section data-testid="test-sla">
      <div class="card-head">
        <div>
          <h2>Time-to-Live SLA</h2>
          <div class="section-sub">Measures from request → verified QR(s), across form/poster permutations.</div>
        </div>
        <div class="btn-row">
          <button class="btn btn-xl" id="btnRunSlaMock" data-testid="btn-sla-mock">Run SLA (Mock)</button>
          <div class="row">
            <input id="eventKey" class="mono" type="text" placeholder="optional: real event id/slug" style="min-width:260px;" data-testid="input-event-key" />
            <button class="btn" id="btnRunSlaReal" data-testid="btn-sla-real">Run SLA (Real)</button>
          </div>
        </div>
      </div>

      <div class="grid-2">
        <section class="bracket">
          <h3>Results</h3>
          <div class="kvs mono small" id="slaResults" data-testid="sla-results">
            <!-- Populated dynamically -->
          </div>
        </section>
        <section class="bracket">
          <h3>Legend & Thresholds</h3>
          <p class="small">
            <span class="pill g">Green</span> &lt; <span id="threshGreen" class="mono"></span> ms<br/>
            <span class="pill y">Yellow</span> &lt; <span id="threshYellow" class="mono"></span> ms<br/>
            <span class="pill r">Red</span> ≥ <span class="mono" id="threshYellow2"></span> ms
          </p>
          <p class="small">
            <strong>Poster readiness =</strong> verified <em>public</em> QR (we never show a QR unless verified).<br/>
            Image/Text/Both label which user-facing path the poster takes; verification criteria remain the same.
          </p>
        </section>
      </div>
    </section>

    <!-- ================= API Contracts (Self-tests) ================= -->
    <section data-testid="test-contracts">
      <div class="card-head">
        <h2>API Contracts</h2>
        <span id="contractsBadge" class="pill">—</span>
      </div>
      <div id="contractsOut" class="code mono small" aria-live="polite"></div>
    </section>

    <!-- ================= Diagnostics (live tail) ================= -->
    <section class="diag" id="diag" data-testid="diag-pane">
      <div class="diag-head">
        <h2>Diagnostics</h2>
        <div class="diag-actions">
          <label class="diag-checkbox"><input type="checkbox" id="chkDiagTail" checked /> Live tail</label>
          <button class="btn" id="btnFlushDiag" data-testid="btn-flush-diag">Flush sample log</button>
        </div>
      </div>
      <div id="diagBody" class="diag-body mono small" role="log" aria-live="polite"></div>
    </section>
  </div>

  <script>
    /* ================= Test Harness · SLA + Smoke ================= */

    const THRESH = { GREEN_MS: 90000, YELLOW_MS: 180000 }; // 90s / 180s
    const SLA = {
      // keys → human labels for the 8 metrics
      BARE_NOPOSTER: 'TtL w/o Form · No Poster',
      BARE_FORM: 'TtL w/ Form · No Poster',
      IMG_NOFORM: 'TtL w/o Form · Poster Image',
      IMG_FORM: 'TtL w/ Form · Poster Image',
      TXT_NOFORM: 'TtL w/o Form · Poster Text',
      TXT_FORM: 'TtL w/ Form · Poster Text',
      BOTH_NOFORM: 'TtL w/o Form · Poster Image+Text',
      BOTH_FORM: 'TtL w/ Form · Poster Image+Text'
    };

    const els = {
      pfMsg: document.getElementById('preflightMsg'),
      pfCtrl: document.getElementById('pf-ctrl-dot'),
      pfTpl: document.getElementById('pf-tpl-dot'),
      pfQr: document.getElementById('pf-qr-dot'),
      btnSmoke: document.getElementById('btnRunSmoke'),
      btnSelfTests: document.getElementById('btnRunSelfTests'),
      btnSlaMock: document.getElementById('btnRunSlaMock'),
      btnSlaReal: document.getElementById('btnRunSlaReal'),
      eventKey: document.getElementById('eventKey'),
      slaResults: document.getElementById('slaResults'),
      contractsBadge: document.getElementById('contractsBadge'),
      contractsOut: document.getElementById('contractsOut'),
      threshGreen: document.getElementById('threshGreen'),
      threshYellow: document.getElementById('threshYellow'),
      threshYellow2: document.getElementById('threshYellow2'),
      diagBody: document.getElementById('diagBody'),
      chkDiagTail: document.getElementById('chkDiagTail'),
      btnFlushDiag: document.getElementById('btnFlushDiag'),
    };

    // Threshold legend
    els.threshGreen.textContent = THRESH.GREEN_MS.toLocaleString();
    els.threshYellow.textContent = THRESH.YELLOW_MS.toLocaleString();
    els.threshYellow2.textContent = THRESH.YELLOW_MS.toLocaleString();

    function badge(ms){
      if (ms < THRESH.GREEN_MS) return '<span class="pill g">G</span>';
      if (ms < THRESH.YELLOW_MS) return '<span class="pill y">Y</span>';
      return '<span class="pill r">R</span>';
    }
    function dot(el, state){ el.className = 'status-dot ' + (state || ''); }

    /** RPC wrapper */
    function rpc(fn, ...args){
      return new Promise((res, rej)=>{
        google.script.run.withSuccessHandler(res).withFailureHandler(e=>rej(e && e.message ? new Error(e.message) : e))[fn](...args);
      });
    }

    /** Log to Diagnostics sheet via backend */
    function log(level, where, msg, data){
      try { google.script.run.clientLog({ level, where, msg, data, ts: Date.now() }); } catch (_) {}
    }

    /** Preflight: control/template/qr cache */
    async function preflight(){
      try {
        const st = await rpc('getControlStatus');
        dot(els.pfCtrl, st.present ? 'g' : (st.err ? 'r' : 'y'));
        dot(els.pfTpl, st.templateId ? 'g' : 'y');
      } catch(_e) { dot(els.pfCtrl,'r'); dot(els.pfTpl,'r'); }
      // QR cache smoke (no-op warmup)
      dot(els.pfQr, 'g');
      els.pfMsg.textContent = 'Preflight checked. Control/Template auto-heal occurs on Admin/Test load.';
    }

    /** Smoke: bundles + link endpoints on mock keys */
    async function runSmoke(){
      const cases = [
        { k:'mock:empty', what:'bundle' },
        { k:'mock:public_qr_ready', what:'public' },
        { k:'mock:signup_qr_ready', what:'signup' }
      ];
      let ok = true, lines = [];
      for (const c of cases){
        try {
          if (c.what==='bundle'){
            const b = await rpc('getPublicBundle', c.k);
            lines.push('bundle '+c.k+': '+(b && b.ok ? 'ok' : 'fail'));
            ok = ok && !!(b && b.ok);
          } else if (c.what==='public') {
            const p = await rpc('getShareQr', c.k);
            lines.push('public '+c.k+': '+(p && p.ok ? 'ok' : 'fail'));
            ok = ok && !!(p && p.ok);
          } else {
            const s = await rpc('getSignupQr', c.k);
            lines.push('signup '+c.k+': '+(s && s.ok ? 'ok' : 'fail'));
            ok = ok && !!(s && s.ok);
          }
        } catch(e){ lines.push(c.what+' '+c.k+': EXC '+String(e)); ok=false; }
      }
      toast(ok ? 'Smoke: PASS' : 'Smoke: FAIL', ok ? '' : 'error');
      log(ok ? 'info':'error', 'test.smoke', ok ? 'pass':'fail', { lines });
    }

    /** Self-tests (backend contract checks) */
    async function runContracts(){
      els.contractsBadge.textContent = '…';
      els.contractsBadge.className = 'pill';
      els.contractsOut.textContent = '(running…)';
      try {
        const r = await rpc('runSelfTests');
        if (r && r.ok){
          const fails = (r.results || []).filter(x => !x.pass);
          els.contractsBadge.textContent = fails.length ? 'FAIL' : 'PASS';
          els.contractsBadge.className = 'pill ' + (fails.length ? 'r' : 'g');
          els.contractsOut.textContent = JSON.stringify(r, null, 2);
          log(fails.length ? 'error':'info', 'test.contracts', fails.length ? 'fail':'pass', { results: r.results });
        } else {
          els.contractsBadge.textContent = 'ERR';
          els.contractsBadge.className = 'pill r';
          els.contractsOut.textContent = JSON.stringify(r || { ok:false }, null, 2);
          log('error', 'test.contracts', 'error', r);
        }
      } catch(e){
        els.contractsBadge.textContent = 'EXC';
        els.contractsBadge.className = 'pill r';
        els.contractsOut.textContent = String(e && e.message || e);
        log('error','test.contracts','exception',{ err: String(e && e.message || e) });
      }
    }

    /** ================= SLA runner =================
     * Poster readiness == verified public QR.
     * For "with form" variants, we also require verified signup QR.
     * Image/Text/Both label the UI path; verification condition is identical (strict QR invariant).
     */
    function msSince(t0){ return Date.now() - t0; }
    function slaRow(label, ms, ok, extra){
      const cls = ok ? '' : ' (timeout)';
      return [
        `<div>${label}</div>`,
        `<div><span class="mono">${ms.toLocaleString()} ms</span> ${badge(ms)} ${extra||''}${ok?'':` <span class="pill r">FAIL</span>`}</div>`
      ].join('');
    }
    function renderSla(results){
      els.slaResults.innerHTML = Object.keys(results).map(k => {
        const r = results[k]; return slaRow(r.label, r.ms, r.ok, r.note || '');
      }).join('');
    }

    async function waitPublicQr(eventKey, timeoutMs=180000, intervalMs=750){
      const t0 = Date.now();
      while (Date.now() - t0 < timeoutMs){
        const r = await rpc('getShareQr', eventKey);
        if (r && r.ok && r.qrB64) return { ok:true, url:r.url, ms: msSince(t0) };
        await sleep(intervalMs);
      }
      return { ok:false, ms: msSince(t0), error:'timeout_public_qr' };
    }
    async function waitSignupQr(eventKey, timeoutMs=180000, intervalMs=750){
      const t0 = Date.now();
      while (Date.now() - t0 < timeoutMs){
        const r = await rpc('getSignupQr', eventKey);
        if (r && r.ok && r.qrB64) return { ok:true, url:r.url, ms: msSince(t0) };
        await sleep(intervalMs);
      }
      return { ok:false, ms: msSince(t0), error:'timeout_signup_qr' };
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function runSla(useMock){
      const started = Date.now();
      const keyReal = (els.eventKey.value || '').trim();

      // Keys for mock vs real. For real, user can pass one key; both public/signup use the same event.
      const keys = useMock ? {
        public: 'mock:public_qr_ready',
        signup: 'mock:signup_qr_ready'
      } : {
        public: keyReal || 'mock:public_qr_ready',
        signup: keyReal || 'mock:signup_qr_ready'
      };

      const results = {};

      // Helper measuring functions
      async function measureBareNoPoster(){
        const t0 = Date.now();
        const p = await waitPublicQr(keys.public);
        return { ok: p.ok, ms: msSince(t0), note: p.ok ? '' : '(timeout)' };
      }
      async function measureWithFormNoPoster(){
        const t0 = Date.now();
        const p1 = await waitPublicQr(keys.public);
        const p2 = await waitSignupQr(keys.signup);
        return { ok: p1.ok && p2.ok, ms: Math.max(p1.ms, p2.ms), note: (p1.ok&&p2.ok)?'':'(timeout)' };
      }
      async function measurePosterPath(withForm){
        const t0 = Date.now();
        const pub = await waitPublicQr(keys.public);
        if (!withForm) return { ok: pub.ok, ms: msSince(t0), note: pub.ok?'':'(timeout)' };
        const su = await waitSignupQr(keys.signup);
        return { ok: pub.ok && su.ok, ms: Math.max(pub.ms, su.ms), note: (pub.ok&&su.ok)?'':'(timeout)' };
      }

      // 1) No form, no poster
      let r1 = await measureBareNoPoster();
      results.BARE_NOPOSTER = { label: SLA.BARE_NOPOSTER, ...r1 }; log(r1.ok?'info':'warn','test.sla','bare_noposter',{ useMock, ...r1 });

      // 2) With form, no poster
      let r2 = await measureWithFormNoPoster();
      results.BARE_FORM = { label: SLA.BARE_FORM, ...r2 }; log(r2.ok?'info':'warn','test.sla','form_noposter',{ useMock, ...r2 });

      // 3) No form, poster IMAGE
      let r3 = await measurePosterPath(false);
      results.IMG_NOFORM = { label: SLA.IMG_NOFORM, ...r3 }; log(r3.ok?'info':'warn','test.sla','poster_image_noform',{ useMock, ...r3 });

      // 4) With form, poster IMAGE
      let r4 = await measurePosterPath(true);
      results.IMG_FORM = { label: SLA.IMG_FORM, ...r4 }; log(r4.ok?'info':'warn','test.sla','poster_image_form',{ useMock, ...r4 });

      // 5) No form, poster TEXT
      let r5 = await measurePosterPath(false);
      results.TXT_NOFORM = { label: SLA.TXT_NOFORM, ...r5 }; log(r5.ok?'info':'warn','test.sla','poster_text_noform',{ useMock, ...r5 });

      // 6) With form, poster TEXT
      let r6 = await measurePosterPath(true);
      results.TXT_FORM = { label: SLA.TXT_FORM, ...r6 }; log(r6.ok?'info':'warn','test.sla','poster_text_form',{ useMock, ...r6 });

      // 7) No form, poster BOTH (image+text)
      let r7 = await measurePosterPath(false);
      results.BOTH_NOFORM = { label: SLA.BOTH_NOFORM, ...r7 }; log(r7.ok?'info':'warn','test.sla','poster_both_noform',{ useMock, ...r7 });

      // 8) With form, poster BOTH (image+text)
      let r8 = await measurePosterPath(true);
      results.BOTH_FORM = { label: SLA.BOTH_FORM, ...r8 }; log(r8.ok?'info':'warn','test.sla','poster_both_form',{ useMock, ...r8 });

      renderSla(results);

      const suiteMs = msSince(started);
      const summary = Object.keys(results).reduce((a,k)=> (a[k]=results[k].ms, a), {});
      log('info','test.sla.summary8','done',{ useMock, suiteMs, ...summary });
      toast('SLA (8) run complete.');
    }

    /** Toasts */
    let toastTimer=null;
    function toast(msg, kind){
      clearTimeout(toastTimer);
      const t = document.createElement('div');
      t.className = 'toast ' + (kind||'');
      t.textContent = msg;
      document.body.appendChild(t);
      toastTimer = setTimeout(()=> t.remove(), 2400);
    }

    /** Diagnostics live tail (front-only marker) */
    function diag(line, level){
      const el = document.createElement('div');
      el.className = 'lvl-' + (level || 'info');
      el.textContent = (new Date()).toISOString() + ' · ' + (level || 'info') + ' · ' + line;
      els.diagBody.prepend(el);
      const keep = 500;
      while (els.diagBody.childNodes.length > keep) els.diagBody.removeChild(els.diagBody.lastChild);
    }

    // Wire buttons
    els.btnRunSlaMock.addEventListener('click', ()=> runSla(true));
    els.btnSlaReal.addEventListener('click', ()=> runSla(false));
    els.btnRunSmoke.addEventListener('click', runSmoke);
    els.btnRunSelfTests.addEventListener('click', runContracts);
    els.btnFlushDiag.addEventListener('click', ()=> {
      log('info','test.flush','sample',{ n: Math.random().toString(36).slice(2,8) });
      diag('flushed sample log → Diagnostics sheet', 'info');
      toast('Sample log sent to Diagnostics');
    });

    // Boot
    document.addEventListener('DOMContentLoaded', async ()=>{
      try { await preflight(); } catch(_) {}
      diag('Test page loaded', 'info');
    });
  </script>
</body>
</html>